{
  "subtopic_id": "predicate_logic",
  "subtopic_name": "Predicate Logic",
  "mode": "finals",
  "difficulty": "difficult",
  "questions": [
    {
      "question": "What is G�del's completeness theorem?",
      "answer": " f iff  f",
      "alternatives": [
        "Completeness"
      ],
      "explanation": "Theorem: provable iff valid. Scope: first-order logic. Implication: no gap between syntax/semantics. Importance: foundational. Developer: Kurt G�del. Significance: first-order = complete."
    },
    {
      "question": "What is G�del's incompleteness theorem?",
      "answer": "Unprovable true statements exist",
      "alternatives": [
        "Incompleteness"
      ],
      "explanation": "Theorem: consistent systems incomplete. Scope: arithmetic. Implication: provability < truth. Importance: major result. Developer: Kurt G�del. Impact: limits formalization."
    },
    {
      "question": "What is Church's thesis?",
      "answer": "Computable = Turing computable",
      "alternatives": [
        "Computability thesis"
      ],
      "explanation": "Thesis: computational ability equivalent Turing machines. Status: widely accepted, unproven. Application: computability definition. Importance: theoretical foundation. Implication: undecidable problems exist."
    },
    {
      "question": "What is decidability?",
      "answer": "Algorithm determines true/false",
      "alternatives": [
        "Computational decidability"
      ],
      "explanation": "Decidability: algorithm terminates with answer. Example: validity of propositional logic decidable. Problem: first-order validity undecidable. Importance: computational limits. Application: complexity."
    },
    {
      "question": "What is semi-decidability?",
      "answer": "Algorithm recognizes true but not false",
      "alternatives": [
        "Partial decidability"
      ],
      "explanation": "Semi-decidable: terminates if true, maybe loops if false. Example: first-order validity semi-decidable. Implication: incomplete automation. Importance: computational classes. Application: theorem proving."
    },
    {
      "question": "What is the Davis-Putnam procedure?",
      "answer": "Algorithm for satisfiability checking",
      "alternatives": [
        "SAT algorithm"
      ],
      "explanation": "Algorithm: systematic search with pruning. Purpose: determine satisfiability. Improvement: DPLL adds more pruning. Application: SAT solving. Importance: foundational algorithm."
    },
    {
      "question": "What is the DPLL algorithm?",
      "answer": "SAT solver with unit propagation",
      "alternatives": [
        "Modern SAT"
      ],
      "explanation": "Algorithm: Davis-Putnam + unit/pure literal. Features: backtracking, learning. Purpose: efficient satisfiability. Application: SAT solvers. Importance: practical algorithm."
    },
    {
      "question": "What is CNF (Conjunctive Normal Form)?",
      "answer": "(ABC)(DE)... form",
      "alternatives": [
        "Normal form"
      ],
      "explanation": "Form: conjunction of disjunctions. Purpose: standardization. Conversion: polynomial time. Application: SAT solving. Importance: standard form. Advantage: suited for resolution."
    },
    {
      "question": "What is DNF (Disjunctive Normal Form)?",
      "answer": "(ABC)(DE)... form",
      "alternatives": [
        "Normal form"
      ],
      "explanation": "Form: disjunction of conjunctions. Purpose: standardization. Conversion: polynomial time. Application: circuit design. Importance: dual form. Disadvantage: exponential size possible."
    },
    {
      "question": "What is the closed world assumption?",
      "answer": "What's not provable is false",
      "alternatives": [
        "CWA"
      ],
      "explanation": "Assumption: closed domain. Consequence: unprovable statements false. Alternative: open world assumption. Application: databases, Prolog. Limitation: incomplete. Importance: semantics choice."
    }
  ]
}