{
  "subtopic_id": "software_design",
  "subtopic_name": "Software Design",
  "mode": "finals",
  "difficulty": "easy",
  "questions": [
    {
      "question": "The architectural pattern that separates data, presentation, and logic.",
      "answer": "MVC",
      "alternatives": [
        "Model-View-Controller"
      ],
      "explanation": "MVC divides applications into Model (data), View (UI), and Controller (business logic) for better organization.",
      "id": "sof_des_sof_des_e_finals_000"
    },
    {
      "question": "The design pattern that ensures only one instance of a class exists.",
      "answer": "Singleton",
      "alternatives": [
        "Singleton Pattern"
      ],
      "explanation": "Singleton pattern restricts a class to a single instance and provides global access to it.",
      "id": "sof_des_sof_des_e_finals_001"
    },
    {
      "question": "The design pattern that provides a simplified interface to a complex subsystem.",
      "answer": "Facade",
      "alternatives": [
        "Facade Pattern"
      ],
      "explanation": "Facade pattern offers a unified, simpler interface to a set of interfaces in a subsystem.",
      "id": "sof_des_sof_des_e_finals_002"
    },
    {
      "question": "The design pattern that allows incompatible interfaces to work together.",
      "answer": "Adapter",
      "alternatives": [
        "Adapter Pattern"
      ],
      "explanation": "Adapter pattern converts one interface into another that clients expect, enabling compatibility.",
      "id": "sof_des_sof_des_e_finals_003"
    },
    {
      "question": "The design pattern for creating objects without specifying their exact classes.",
      "answer": "Factory",
      "alternatives": [
        "Factory Pattern"
      ],
      "explanation": "Factory pattern provides an interface for creating objects without specifying concrete classes.",
      "id": "sof_des_sof_des_e_finals_004"
    },
    {
      "question": "The design principle stating each class should have one reason to change.",
      "answer": "Single Responsibility Principle",
      "alternatives": [
        "SRP"
      ],
      "explanation": "SRP states that a class should have only one job or responsibility, making it easier to maintain.",
      "id": "sof_des_sof_des_e_finals_005"
    },
    {
      "question": "The design principle advocating not repeating code or knowledge.",
      "answer": "DRY",
      "alternatives": [
        "Don't Repeat Yourself"
      ],
      "explanation": "DRY principle emphasizes reducing repetition by abstracting common functionality.",
      "id": "sof_des_sof_des_e_finals_006"
    },
    {
      "question": "The measure of how related functions within a module are.",
      "answer": "Cohesion",
      "alternatives": [
        "Module Cohesion"
      ],
      "explanation": "Cohesion measures how closely related and focused the responsibilities of a module are.",
      "id": "sof_des_sof_des_e_finals_007"
    },
    {
      "question": "The degree of interdependence between software modules.",
      "answer": "Coupling",
      "alternatives": [
        "Module Coupling"
      ],
      "explanation": "Coupling measures how much one module depends on others; low coupling is preferable.",
      "id": "sof_des_sof_des_e_finals_008"
    },
    {
      "question": "An architectural style with independent, deployable services.",
      "answer": "Microservices",
      "alternatives": [
        "Microservices Architecture"
      ],
      "explanation": "Microservices architecture structures applications as collections of loosely coupled services.",
      "id": "sof_des_sof_des_e_finals_009"
    }
  ]
}