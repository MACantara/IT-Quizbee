{
  "subtopic_id": "oop_basics",
  "subtopic_name": "OOP Basics",
  "mode": "finals",
  "difficulty": "difficult",
  "questions": [
    {
      "question": "What design concept groups related classes together?",
      "answer": "package",
      "alternatives": [
        "namespace",
        "module"
      ],
      "explanation": "Packages organize classes into logical groups to prevent naming conflicts.",
      "id": "oop_bas_oop_bas_d_finals_000"
    },
    {
      "question": "What allows multiple objects to share the same memory for common data?",
      "answer": "flyweight pattern",
      "alternatives": [
        "flyweight"
      ],
      "explanation": "Flyweight pattern minimizes memory usage by sharing immutable data.",
      "id": "oop_bas_oop_bas_d_finals_001"
    },
    {
      "question": "What technique creates objects without specifying exact classes?",
      "answer": "factory pattern",
      "alternatives": [
        "factory method"
      ],
      "explanation": "Factory pattern delegates object creation to factory methods or classes.",
      "id": "oop_bas_oop_bas_d_finals_002"
    },
    {
      "question": "What ensures only one instance of a class exists?",
      "answer": "singleton pattern",
      "alternatives": [
        "singleton"
      ],
      "explanation": "Singleton pattern restricts class instantiation to a single object.",
      "id": "oop_bas_oop_bas_d_finals_003"
    },
    {
      "question": "What programming paradigm combines OOP with functional programming?",
      "answer": "multi-paradigm",
      "alternatives": [
        "hybrid programming"
      ],
      "explanation": "Multi-paradigm languages support multiple programming styles including OOP and functional.",
      "id": "oop_bas_oop_bas_d_finals_004"
    },
    {
      "question": "What mechanism allows a method to exist in name only without implementation?",
      "answer": "abstract method",
      "alternatives": [
        "pure virtual method"
      ],
      "explanation": "Abstract methods declare signatures that subclasses must implement.",
      "id": "oop_bas_oop_bas_d_finals_005"
    },
    {
      "question": "What concept treats functions as first-class objects in OOP?",
      "answer": "higher-order functions",
      "alternatives": [
        "function objects",
        "functors"
      ],
      "explanation": "Higher-order functions can accept or return other functions as parameters.",
      "id": "oop_bas_oop_bas_d_finals_006"
    },
    {
      "question": "What allows objects to define custom behavior for standard operators?",
      "answer": "operator overloading",
      "alternatives": [
        "overloading"
      ],
      "explanation": "Operator overloading redefines how operators work with custom objects.",
      "id": "oop_bas_oop_bas_d_finals_007"
    },
    {
      "question": "What type of binding resolves method calls at compile time?",
      "answer": "static binding",
      "alternatives": [
        "early binding",
        "compile-time binding"
      ],
      "explanation": "Static binding determines method calls during compilation.",
      "id": "oop_bas_oop_bas_d_finals_008"
    },
    {
      "question": "What type of binding resolves method calls at runtime?",
      "answer": "dynamic binding",
      "alternatives": [
        "late binding",
        "runtime binding"
      ],
      "explanation": "Dynamic binding defers method resolution until program execution.",
      "id": "oop_bas_oop_bas_d_finals_009"
    }
  ]
}