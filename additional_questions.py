"""
Additional questions for Computer Architecture & IT Security subtopics.
This module extends the QUESTIONS_DB with more subtopic questions.
"""

# 3. Instruction Set Architecture
INSTRUCTION_SET_QUESTIONS = {
    "easy": [
        {"question": "What is the architecture design philosophy that uses a small set of simple, fast instructions?", "answer": "RISC (Reduced Instruction Set Computer)", "alternatives": ["Reduced Instruction Set Computer", "RISC Architecture"], "explanation": "RISC (Reduced Instruction Set Computer) philosophy emphasizes a small set of simple instructions that execute in a single clock cycle. This approach, used in ARM and MIPS processors, prioritizes simplicity and speed over instruction complexity, relying on compilers to generate efficient code sequences."},
        {"question": "What is the part of an instruction that specifies the operation to be performed?", "answer": "Opcode", "alternatives": ["Operation Code"], "explanation": "The opcode (operation code) is the portion of a machine instruction that specifies the operation to perform, such as ADD, LOAD, or JUMP. It tells the CPU what action to execute, while operands specify what data to use."},
        {"question": "What is the name of the interface that defines all instructions a CPU can execute?", "answer": "ISA (Instruction Set Architecture)", "alternatives": ["Instruction Set Architecture"], "explanation": "The Instruction Set Architecture (ISA) is the abstract interface between hardware and software, defining all instructions, registers, memory addressing modes, and data types a processor supports. It's crucial for software compatibility - programs compiled for one ISA won't run on a processor with a different ISA without emulation."},
        {"question": "What popular instruction set architecture is used in most smartphones and tablets?", "answer": "ARM", "alternatives": ["ARM Architecture", "Advanced RISC Machine"], "explanation": "ARM (Advanced RISC Machine, originally Acorn RISC Machine) is a RISC-based ISA dominant in mobile devices due to its power efficiency. ARM processors power most smartphones, tablets, and increasingly laptops, with Apple's M-series chips and Qualcomm's Snapdragon being notable examples."},
        {"question": "What is the low-level programming language that uses mnemonics for machine instructions?", "answer": "Assembly Language", "alternatives": ["Assembly", "Assembler Language"], "explanation": "Assembly language uses human-readable mnemonics (like MOV, ADD, JMP) instead of binary machine code, making it easier to write low-level programs. Each assembly instruction typically corresponds to one machine instruction, and an assembler translates assembly code into machine code."},
        {"question": "What instruction set architecture is used by Intel and AMD processors?", "answer": "x86", "alternatives": ["x86 Architecture", "IA-32"], "explanation": "x86 is a CISC instruction set architecture originally developed by Intel, used in most desktop and laptop computers. It includes 32-bit (IA-32) and 64-bit (x86-64/AMD64) versions. Despite being complex, x86's backward compatibility has made it the dominant desktop/server architecture."},
        {"question": "What is the binary representation of instructions that the CPU directly executes?", "answer": "Machine Code", "alternatives": ["Machine Language", "Binary Code"], "explanation": "Machine code consists of binary instructions (1s and 0s) that the CPU can directly execute without translation. Every program must ultimately be converted to machine code, whether from high-level languages (via compilation) or assembly language (via assembly)."},
        {"question": "What addressing mode uses a fixed memory address in the instruction?", "answer": "Direct Addressing", "alternatives": ["Absolute Addressing"], "explanation": "In direct addressing mode, the instruction contains the actual memory address of the operand. This is simple and fast but limits flexibility since addresses are hardcoded. For example, 'LOAD 1000' would load the value from memory address 1000."},
        {"question": "What is the term for the method used to specify where operands are located?", "answer": "Addressing Mode", "alternatives": ["Addressing Modes"], "explanation": "Addressing modes determine how the CPU interprets operand specifications in instructions. Common modes include immediate (value in instruction), direct (address in instruction), indirect (address of address), and register (operand in register). Different modes offer tradeoffs between simplicity, flexibility, and efficiency."},
        {"question": "What type of instruction set has variable-length instructions?", "answer": "CISC", "alternatives": ["Complex Instruction Set Computer"], "explanation": "CISC (Complex Instruction Set Computer) architectures like x86 use variable-length instructions, ranging from 1 to 15+ bytes. This allows compact code representation but complicates instruction decoding. In contrast, RISC architectures typically use fixed-length instructions (e.g., 32 bits) for simpler decoding."}
    ],
    "average": [
        {"question": "What RISC-based instruction set architecture is gaining popularity for its open-source, royalty-free nature?", "answer": "RISC-V", "alternatives": ["RISCV"], "explanation": "RISC-V is an open-source RISC instruction set architecture that anyone can use without royalties. Unlike ARM or x86, RISC-V specifications are freely available, allowing custom processor designs. It's gaining traction in embedded systems, research, and increasingly in commercial products, offering an alternative to proprietary ISAs."},
        {"question": "What addressing mode calculates the operand address by adding a constant to a register value?", "answer": "Base-Displacement addressing", "alternatives": ["Indexed addressing", "Register-Offset addressing"], "explanation": "Base-displacement (or indexed) addressing adds a constant offset to a base register value to calculate the operand address. This is extremely useful for accessing array elements, structure fields, and stack variables. For example, accessing array[5] might use base register + (5 Ã— element_size)."},
        {"question": "What is the term for instructions that operate on operands located in CPU registers only?", "answer": "Register-to-Register instructions", "alternatives": ["Register operations", "R-type instructions"], "explanation": "Register-to-register (or R-type) instructions operate entirely on register operands without accessing memory. They're the fastest instructions since registers are immediately accessible. RISC architectures emphasize register operations, using separate load/store instructions for memory access (load-store architecture)."},
        {"question": "What technique allows a single instruction to operate on multiple data elements simultaneously?", "answer": "SIMD (Single Instruction Multiple Data)", "alternatives": ["Vector processing", "SIMD"], "explanation": "SIMD allows a single instruction to perform the same operation on multiple data elements in parallel. Modern processors include SIMD extensions (SSE, AVX for x86; NEON for ARM) that can process 4, 8, or 16 values simultaneously. This is crucial for multimedia processing, scientific computing, and machine learning."},
        {"question": "What is the name for instructions that transfer control to a different part of the program?", "answer": "Branch instructions", "alternatives": ["Jump instructions", "Control flow instructions"], "explanation": "Branch (or jump) instructions alter program control flow by changing the program counter to a different address. They include conditional branches (branch if condition true), unconditional jumps, function calls, and returns. Efficient branch handling is critical for performance, hence sophisticated branch prediction in modern CPUs."},
        {"question": "What addressing mode uses the contents of a register as the memory address?", "answer": "Register Indirect addressing", "alternatives": ["Indirect addressing", "Register deferred"], "explanation": "In register indirect addressing, a register contains the memory address of the operand, not the operand itself. This enables dynamic addressing, crucial for pointer operations, dynamic data structures, and implementing arrays. For example, if R1=1000, then 'LOAD (R1)' loads from address 1000."},
        {"question": "What is the term for ISA features that maintain compatibility with older software?", "answer": "Backward compatibility", "alternatives": ["Legacy support"], "explanation": "Backward compatibility ensures new processors can run software designed for older processors in the same family. x86 maintains remarkable backward compatibility - modern 64-bit processors can run 16-bit DOS programs. This is crucial for commercial success but constrains architectural innovation."},
        {"question": "What instruction format dedicates separate fields for opcode and operands with fixed sizes?", "answer": "Fixed-format instructions", "alternatives": ["RISC format", "Regular format"], "explanation": "Fixed-format instructions use predetermined field positions and sizes for opcode and operands. This simplifies decoding logic and enables faster instruction processing, typical of RISC architectures. All instructions are the same length (e.g., 32 bits), though this may waste encoding space compared to variable-length formats."},
        {"question": "What is the technique where the compiler, not hardware, schedules instructions to avoid hazards?", "answer": "Static scheduling", "alternatives": ["Compile-time scheduling"], "explanation": "Static scheduling relies on the compiler to arrange instructions to minimize pipeline stalls and hazards. This is common in RISC processors where the ISA exposes pipeline behavior to software. The compiler inserts NOPs or reorders independent instructions, reducing hardware complexity at the cost of larger code size."},
        {"question": "What addressing mode automatically increments or decrements a register after using it?", "answer": "Auto-increment/Auto-decrement addressing", "alternatives": ["Post-increment addressing", "Auto-indexing"], "explanation": "Auto-increment/decrement addressing automatically modifies the register after (post) or before (pre) using it as an address. This is extremely efficient for traversing arrays or stacks, eliminating separate increment instructions. For example, 'LOAD (R1)+' loads from R1's address then increments R1."}
    ],
    "difficult": [
        {"question": "What ISA feature allows conditional execution of instructions without branching?", "answer": "Predicated execution", "alternatives": ["Conditional execution", "Predication"], "explanation": "Predicated (or conditional) execution allows instructions to be conditionally executed based on a predicate condition without branching. ARM and IA-64 support this extensively. Instead of 'if (cond) x=a; else x=b;' requiring branches, both assignments execute with one's result discarded based on the condition, eliminating branch misprediction penalties."},
        {"question": "What ISA design principle advocates that frequently used operations should execute faster?", "answer": "Common case optimization", "alternatives": ["Make the common case fast"], "explanation": "The 'make the common case fast' principle guides ISA and microarchitecture design. Since simple operations like loads, stores, and arithmetic dominate program execution, they should be fast even if it makes rare operations slower. This justifies RISC's simple instructions and hardware optimization for common patterns."},
        {"question": "What technique allows processors to expose parallelism explicitly through very long instruction words?", "answer": "VLIW (Very Long Instruction Word)", "alternatives": ["Very Long Instruction Word", "Explicitly Parallel Instruction Computing"], "explanation": "VLIW architectures package multiple operations into a single long instruction word, with the compiler scheduling operations for parallel execution. Unlike superscalar processors that discover parallelism dynamically, VLIW relies entirely on compiler analysis. Intel's Itanium used VLIW (called EPIC), but compiler limitations hindered commercial success."},
        {"question": "What ISA feature allows instructions to specify multiple operations bundled together?", "answer": "Instruction fusion", "alternatives": ["Macro-op fusion", "Op fusion"], "explanation": "Instruction fusion (or macro-op fusion) combines multiple simple instructions into a single complex operation at decode time. For example, compare-and-branch might fuse into one micro-op. This reduces pressure on execution resources and improves performance while maintaining ISA simplicity. Modern x86 processors extensively use fusion."},
        {"question": "What design philosophy motivated RISC development in opposition to increasingly complex CISC processors?", "answer": "ISA minimalism", "alternatives": ["Simplicity principle", "RISC philosophy"], "explanation": "RISC emerged from research showing that CISC complexity provided diminishing returns - most programs used simple instructions primarily. RISC philosophy advocates for simple, uniform instructions that execute quickly, moving complexity to the compiler. This enables higher clock speeds, simpler pipelines, and more efficient hardware implementation."},
        {"question": "What addressing mode allows position-independent code by using the program counter as a base?", "answer": "PC-relative addressing", "alternatives": ["Program counter relative", "IP-relative"], "explanation": "PC-relative addressing calculates addresses relative to the current program counter, enabling position-independent code that works regardless of where it's loaded in memory. This is crucial for shared libraries, relocatable code, and modern security features like ASLR. Branch instructions typically use PC-relative addressing."},
        {"question": "What ISA extension adds instructions specifically for accelerating cryptographic operations?", "answer": "AES-NI", "alternatives": ["AES New Instructions", "Crypto extensions"], "explanation": "AES-NI (Advanced Encryption Standard New Instructions) provides hardware acceleration for AES encryption/decryption, offering 3-10Ã— performance improvement over software implementation. Similar extensions exist for other crypto operations (SHA, etc.). These specialized instructions demonstrate the trend of adding domain-specific accelerators to general-purpose ISAs."},
        {"question": "What technique allows ISAs to add new instruction without breaking compatibility using instruction prefixes or modes?", "answer": "ISA extensions", "alternatives": ["Instruction set extensions", "ISA evolution"], "explanation": "ISA extensions add new capabilities while maintaining backward compatibility through various mechanisms: using previously undefined opcodes, adding instruction prefixes (x86's 0x0F prefix), or mode bits. x86 evolved from 16-bit to 64-bit through extensions (MMX, SSE, AVX), maintaining compatibility across decades while gradually increasing complexity."},
        {"question": "What addressing mode chains multiple indirections to reach the final operand location?", "answer": "Multi-level indirect addressing", "alternatives": ["Cascaded indirect", "Pointer chain"], "explanation": "Multi-level indirect addressing follows a chain of pointers through memory to reach the operand. While conceptually simple (like following linked structures), hardware support is rare due to multiple memory accesses. It's typically implemented in software using multiple instructions, though some historical architectures provided hardware support."},
        {"question": "What ISA characteristic measures the degree to which instructions are orthogonal and composable?", "answer": "ISA regularity", "alternatives": ["Orthogonality", "Instruction uniformity"], "explanation": "ISA regularity (or orthogonality) means instructions work consistently across addressing modes, data types, and operands. Highly regular ISAs like RISC are easier to learn, compile for, and implement in hardware. In contrast, x86's irregularity (special cases, exceptions, asymmetric registers) complicates both hardware and software but evolved from historical constraints."}
    ]
}

# 4. Pipelining 
PIPELINING_QUESTIONS = {
    "easy": [
        {"question": "What is the technique of breaking instruction execution into stages like an assembly line?", "answer": "Pipelining", "alternatives": ["Instruction pipelining", "Pipeline"], "explanation": "Pipelining divides instruction execution into stages (fetch, decode, execute, memory, write-back), allowing multiple instructions to be processed simultaneously at different stages, like an assembly line. This increases throughput without reducing individual instruction latency."},
        {"question": "What is the term for a situation where the pipeline must wait because the next instruction depends on a previous one?", "answer": "Pipeline stall", "alternatives": ["Bubble", "Stall", "Pipeline delay"], "explanation": "A pipeline stall (or bubble) occurs when the pipeline must pause because an instruction cannot proceed to the next stage. This wastes clock cycles and reduces throughput. Common causes include data hazards, control hazards, and structural hazards."},
        {"question": "What is the first stage of a typical instruction pipeline that retrieves instructions from memory?", "answer": "Fetch", "alternatives": ["Instruction Fetch", "IF stage"], "explanation": "The Fetch stage retrieves the next instruction from memory using the program counter address. It's the first stage in a typical 5-stage pipeline (Fetch, Decode, Execute, Memory, Write-back). Efficient fetching is crucial since it feeds the entire pipeline."},
        {"question": "What type of hazard occurs when an instruction needs data that hasn't been computed yet?", "answer": "Data hazard", "alternatives": ["Data dependency"], "explanation": "Data hazards occur when an instruction depends on the result of a previous instruction still in the pipeline. For example, if instruction 2 needs the result of instruction 1, but instruction 1 hasn't reached the write-back stage yet, a data hazard exists."},
        {"question": "What is the term for the wasted time in a pipeline due to hazards or dependencies?", "answer": "Pipeline overhead", "alternatives": ["Stall cycles", "Bubble cycles"], "explanation": "Pipeline overhead refers to wasted clock cycles where pipeline stages sit idle due to hazards, preventing the pipeline from achieving its theoretical maximum throughput. Minimizing overhead through hazard detection and resolution is crucial for pipeline efficiency."},
        {"question": "In a 5-stage pipeline, what is the stage that interprets the instruction and reads operands?", "answer": "Decode", "alternatives": ["Instruction Decode", "ID stage"], "explanation": "The Decode stage interprets the instruction opcode, identifies required operands, and reads values from registers. It's the second stage in a classic 5-stage RISC pipeline and prepares everything needed for the Execute stage."},
        {"question": "What is the maximum number of instructions that can be simultaneously in different stages of an N-stage pipeline?", "answer": "N", "alternatives": ["N instructions"], "explanation": "An N-stage pipeline can have at most N instructions in flight simultaneously, one per stage. For example, a 5-stage pipeline can process 5 instructions at once. This is the key to pipelining's performance improvement - overlapping execution of multiple instructions."},
        {"question": "What technique inserts wasted cycles (NOPs) to resolve pipeline hazards?", "answer": "Pipeline stalling", "alternatives": ["Inserting bubbles", "Adding NOPs"], "explanation": "Pipeline stalling intentionally inserts empty cycles (bubbles or NOPs) to delay dependent instructions until their operands are ready. While simple to implement, stalling wastes cycles and reduces pipeline efficiency. More sophisticated techniques like forwarding can often avoid stalls."},
        {"question": "What is the term for when two instructions try to use the same hardware resource simultaneously?", "answer": "Structural hazard", "alternatives": ["Resource conflict"], "explanation": "Structural hazards occur when hardware resources can't support all concurrent operations in a pipeline. For example, if there's only one memory port but both fetch and memory stages need to access memory simultaneously, a structural hazard exists. Solutions include adding more resources or scheduling to avoid conflicts."},
        {"question": "What pipeline stage performs arithmetic, logical, and comparison operations?", "answer": "Execute", "alternatives": ["EX stage", "Execution stage"], "explanation": "The Execute (EX) stage performs the actual operation specified by the instruction: arithmetic (add, subtract), logical (AND, OR), shifts, or comparisons. It's the third stage in a classic 5-stage pipeline and is where the ALU does its work."}
    ],
    "average": [
        {"question": "What technique bypasses the write-back stage to directly forward results to dependent instructions?", "answer": "Data forwarding", "alternatives": ["Bypassing", "Short-circuiting"], "explanation": "Data forwarding (or bypassing) provides results directly from one pipeline stage to another without waiting for write-back to registers. For example, the ALU output can be forwarded immediately to a dependent instruction's ALU input, avoiding stalls. This is a key technique for maintaining pipeline efficiency."},
        {"question": "What type of hazard occurs when pipeline decisions depend on branch outcomes not yet determined?", "answer": "Control hazard", "alternatives": ["Branch hazard"], "explanation": "Control hazards (or branch hazards) occur when the pipeline must make decisions before knowing whether a branch will be taken. The pipeline doesn't know which instruction to fetch next until the branch condition is evaluated, potentially several stages later, causing pipeline stalls or requiring speculative execution."},
        {"question": "What is the technique where the compiler rearranges instructions to minimize pipeline stalls?", "answer": "Instruction scheduling", "alternatives": ["Code scheduling", "Compiler scheduling"], "explanation": "Instruction scheduling is a compiler optimization that reorders independent instructions to minimize pipeline stalls. The compiler analyzes data dependencies and arranges instructions to maximize pipeline utilization, filling potential stall cycles with useful work. This is especially important for statically scheduled RISC processors."},
        {"question": "What is the RAW (Read After Write) hazard where an instruction needs data before it's written?", "answer": "True dependency", "alternatives": ["Data dependency", "RAW hazard"], "explanation": "A RAW (Read After Write) hazard is a true data dependency where an instruction must read a value that a previous instruction will write. For example: 'ADD R1, R2, R3' followed by 'SUB R4, R1, R5' has a RAW hazard on R1. The second instruction must wait for R1 to be written. Forwarding can often resolve RAW hazards."},
        {"question": "What technique speculatively executes instructions from both branch paths simultaneously?", "answer": "Multipath execution", "alternatives": ["Eager execution"], "explanation": "Multipath (or eager) execution speculatively executes both possible branch paths simultaneously, keeping both results until the branch resolves. While resource-intensive, this eliminates branch misprediction penalties entirely. It's practical only for short instruction sequences due to resource constraints."},
        {"question": "What is the maximum theoretical speedup achievable by an N-stage pipeline compared to unpipelined execution?", "answer": "N", "alternatives": ["N times", "Linear speedup"], "explanation": "The theoretical maximum speedup of an N-stage pipeline is N times the unpipelined performance, assuming perfect conditions (no hazards, balanced stages). In practice, hazards, unbalanced stages, and overhead reduce actual speedup. For example, a 5-stage pipeline theoretically provides 5Ã— speedup."},
        {"question": "What WAW (Write After Write) hazard occurs when instructions write to the same register out of order?", "answer": "Output dependency", "alternatives": ["WAW hazard"], "explanation": "A WAW (Write After Write) hazard is an output dependency where two instructions write to the same register, and they might complete out of order. For example, if instruction 2 writes R1 before instruction 1 (which also writes R1), the final value would be incorrect. Register renaming typically resolves WAW hazards."},
        {"question": "What is the term for the time between injecting consecutive instructions into the pipeline?", "answer": "Pipeline initiation interval", "alternatives": ["Throughput rate"], "explanation": "The pipeline initiation interval (or issue rate) is the time between starting consecutive instructions. In an ideal pipeline, it's one clock cycle - a new instruction enters every cycle. The reciprocal gives the throughput. Hazards increase the initiation interval, reducing throughput."},
        {"question": "What technique delays branch resolution while continuing to execute subsequent instructions?", "answer": "Delayed branching", "alternatives": ["Branch delay slot"], "explanation": "Delayed branching exposes the branch delay to the ISA - the instruction(s) immediately following a branch execute regardless of the branch outcome. The compiler fills these 'delay slots' with useful instructions from before the branch or makes them NOPs. This was common in early RISC processors (MIPS, SPARC)."},
        {"question": "What is the WAR (Write After Read) hazard that occurs only with out-of-order execution?", "answer": "Anti-dependency", "alternatives": ["WAR hazard"], "explanation": "A WAR (Write After Read) anti-dependency occurs when an instruction writes a value before a previous instruction reads the old value. This only causes problems with out-of-order execution since in-order pipelines naturally avoid it. Register renaming eliminates WAR hazards by giving each write a unique destination."}
    ],
    "difficult": [
        {"question": "What advanced technique allows a pipeline to continue execution past conditional branches before the condition is known?", "answer": "Speculative execution", "alternatives": ["Branch speculation"], "explanation": "Speculative execution allows the pipeline to continue beyond branches by guessing the outcome and executing along the predicted path. If the prediction is correct, performance improves; if wrong, the speculatively executed work is discarded and the pipeline restarts from the correct path. This trades occasional penalties for usually avoiding stalls."},
        {"question": "What hardware structure tracks which pipeline stages have produced results available for forwarding?", "answer": "Scoreboard", "alternatives": ["Hazard detection unit"], "explanation": "A scoreboard is a hardware table that tracks register availability and pending operations, enabling hazard detection and resolution. It monitors which instructions are using which registers and controls forwarding and stalling. Scoreboards are central to Tomasulo's algorithm and other dynamic scheduling schemes."},
        {"question": "What is the phenomenon where deeper pipelines provide diminishing returns and eventually hurt performance?", "answer": "Pipeline depth limitation", "alternatives": ["Deep pipeline penalty"], "explanation": "Beyond a certain depth, adding pipeline stages hurts performance due to increased branch misprediction penalties, forwarding complexity, and overhead. Each added stage reduces per-stage work but increases pipeline latency, making branch mispredictions more costly. Modern designs balance depth (typically 10-20 stages) against these factors."},
        {"question": "What technique uses multiple parallel pipelines to issue multiple instructions per clock cycle?", "answer": "Superscalar execution", "alternatives": ["Multiple issue", "Superscalar"], "explanation": "Superscalar processors have multiple parallel pipelines, allowing them to fetch, decode, and execute multiple instructions per cycle. A 4-wide superscalar can theoretically complete 4 instructions per clock. This requires significant hardware for dependency checking, multiple execution units, and sophisticated scheduling."},
        {"question": "What is the latency penalty for a branch misprediction in a pipeline with N stages between fetch and execute?", "answer": "N cycles", "alternatives": ["N clock cycles"], "explanation": "When a branch mispredicts in an N-stage pipeline, all speculatively fetched instructions (up to N-1) must be flushed, wasting N cycles before correct-path instructions enter execution. This is why deep pipelines are vulnerable to control hazards and why accurate branch prediction is crucial for performance."},
        {"question": "What technique saves pipeline state at branch points to enable rapid recovery from mispredictions?", "answer": "Checkpoint recovery", "alternatives": ["State checkpointing"], "explanation": "Checkpoint recovery saves the processor state (registers, flags) at branch points. On misprediction, instead of flushing the entire pipeline and re-fetching instructions, the checkpoint is restored, reducing recovery time. This is especially valuable in deep pipelines where misprediction penalties are severe."},
        {"question": "What hardware structure allows out-of-order execution while maintaining in-order commit?", "answer": "Reorder buffer", "alternatives": ["ROB", "Completion buffer"], "explanation": "The reorder buffer (ROB) is a circular buffer that holds instructions in program order from dispatch until retirement. Instructions execute out-of-order but commit in-order from the ROB, maintaining precise exceptions and architectural state. The ROB enables aggressive out-of-order execution while preserving sequential semantics."},
        {"question": "What advanced scheduling technique issues instructions to reservation stations that execute when operands arrive?", "answer": "Tomasulo's algorithm", "alternatives": ["Tomasulo scheduling"], "explanation": "Tomasulo's algorithm uses reservation stations to track instructions waiting for operands. When results are produced, they're broadcast to all stations; ready instructions execute immediately. This enables out-of-order execution, register renaming, and dynamic scheduling without compiler support. Tomasulo's algorithm was pioneering in enabling high-performance out-of-order processors."},
        {"question": "What is the technique of executing multiple iterations of a loop in parallel across pipeline stages?", "answer": "Software pipelining", "alternatives": ["Loop pipelining", "Modulo scheduling"], "explanation": "Software pipelining (or modulo scheduling) rearranges loop iterations so different iterations execute in parallel pipeline stages. Instead of completing iteration N before starting N+1, operations from multiple iterations overlap. This is like loop unrolling but maintains compact code while exposing parallelism. It requires sophisticated compiler analysis of loop-carried dependencies."},
        {"question": "What phenomenon causes performance degradation when pipeline stages have significantly different execution times?", "answer": "Pipeline imbalance", "alternatives": ["Stage imbalance"], "explanation": "Pipeline imbalance occurs when stages have unequal delays, causing the slowest stage to limit overall throughput (the pipeline is only as fast as its slowest stage). Ideally, all stages should take equal time. Imbalance wastes potential performance since faster stages sit idle waiting for slower ones. Careful pipeline design aims to balance stage complexity."}
    ]
}

# Continue with remaining subtopics...
# This file can be imported by question_generator.py to extend the database

ALL_ADDITIONAL_QUESTIONS = {
    'instruction_set': INSTRUCTION_SET_QUESTIONS,
    'pipelining': PIPELINING_QUESTIONS
}

# 5. Parallel Processing
PARALLEL_PROCESSING_QUESTIONS = {
    "easy": [
        {"question": "What term describes performing multiple operations or tasks simultaneously?", "answer": "Parallelism", "alternatives": ["Parallel processing", "Concurrent processing"], "explanation": "Parallelism involves executing multiple operations simultaneously to improve performance. This can occur at different levels: instruction-level (executing multiple instructions at once), thread-level (running multiple threads), or task-level (distributing work across multiple processors)."},
        {"question": "What type of parallel processing has multiple processing units with shared memory?", "answer": "Multiprocessor", "alternatives": ["Shared memory multiprocessor", "SMP"], "explanation": "Multiprocessor systems have multiple CPUs sharing a common memory space. This allows different processors to access the same data directly, simplifying programming but requiring synchronization to prevent conflicts. Symmetric multiprocessors (SMP) are common in modern servers and workstations."},
        {"question": "What is the term for running multiple instructions from a single instruction stream in parallel?", "answer": "SIMD (Single Instruction Multiple Data)", "alternatives": ["Vector processing"], "explanation": "SIMD executes the same operation on multiple data elements simultaneously. One instruction operates on vectors of data rather than single values. This is efficient for data-parallel workloads like image processing, where the same operation applies to many pixels."},
        {"question": "What type of parallelism exists when multiple processors execute different programs on different data?", "answer": "MIMD (Multiple Instruction Multiple Data)", "alternatives": ["Multiple Instruction Multiple Data"], "explanation": "MIMD systems have multiple processors independently executing different instructions on different data. This is the most flexible parallel architecture, supporting both data and task parallelism. Modern multicore processors and computer clusters are MIMD systems."},
        {"question": "What is the term for dividing a large problem into smaller sub-problems that can be solved in parallel?", "answer": "Decomposition", "alternatives": ["Problem decomposition", "Parallelization"], "explanation": "Decomposition breaks a large problem into independent sub-problems that can execute in parallel. Effective decomposition is key to parallel programming success, requiring identification of independent computations and managing dependencies between sub-problems."},
        {"question": "What hardware feature allows a CPU to have multiple independent processing cores on a single chip?", "answer": "Multicore", "alternatives": ["Multi-core processor", "Multicore architecture"], "explanation": "Multicore processors integrate multiple complete CPU cores on a single chip, each capable of independent execution. This provides genuine parallelism within a single package, improving performance for multi-threaded applications while managing power consumption better than increasing clock speeds."},
        {"question": "What is the term for the overhead involved in distributing work among parallel processors?", "answer": "Parallelization overhead", "alternatives": ["Parallel overhead", "Coordination cost"], "explanation": "Parallelization overhead includes time spent distributing work, synchronizing processors, communicating between them, and combining results. This overhead can limit speedup - if it's too high, parallel execution might be slower than sequential. Efficient parallel algorithms minimize this overhead."},
        {"question": "What law states that speedup is limited by the sequential portion of a program?", "answer": "Amdahl's Law", "alternatives": ["Amdahl"], "explanation": "Amdahl's Law states that the maximum speedup of a program is limited by its sequential fraction. Even with infinite processors, if 10% of the program must execute sequentially, maximum speedup is 10Ã—. This highlights the importance of maximizing the parallel portion of programs."},
        {"question": "What term describes multiple processors working on a single shared task?", "answer": "Data parallelism", "alternatives": ["Data-parallel processing"], "explanation": "Data parallelism divides data among processors, with each processor performing the same operation on different data subsets. This is effective for problems with large data sets where the same operation applies to all elements, like matrix operations or image filtering."},
        {"question": "What is the maximum theoretical speedup when using N processors?", "answer": "N", "alternatives": ["Linear speedup", "N times"], "explanation": "The theoretical maximum speedup with N processors is NÃ— (linear speedup), meaning the parallel version runs N times faster than serial execution. However, real speedup is usually less due to parallelization overhead, sequential portions (Amdahl's Law), and communication costs."}
    ],
    "average": [
        {"question": "What type of memory architecture has each processor with its own local memory?", "answer": "Distributed memory", "alternatives": ["Distributed shared memory"], "explanation": "In distributed memory systems, each processor has its own local memory, and processors communicate by passing messages. This scales better than shared memory for large systems but requires explicit communication programming. Computer clusters and supercomputers typically use distributed memory."},
        {"question": "What synchronization primitive ensures mutual exclusion for critical sections?", "answer": "Lock", "alternatives": ["Mutex", "Mutual exclusion lock"], "explanation": "Locks (or mutexes) provide mutual exclusion, ensuring only one thread accesses a critical section at a time. Before entering protected code, a thread acquires the lock; afterward, it releases it. This prevents race conditions but requires careful programming to avoid deadlocks."},
        {"question": "What is the phenomenon where adding more processors provides diminishing returns?", "answer": "Scalability limitation", "alternatives": ["Parallel efficiency degradation"], "explanation": "As more processors are added, efficiency typically decreases due to increased communication overhead, synchronization costs, and load imbalance. This is why real speedup is sublinear - doubling processors doesn't double performance. Strong scaling (fixed problem size) hits limits faster than weak scaling (problem size grows with processors)."},
        {"question": "What parallel programming model passes messages between independent processes?", "answer": "Message passing", "alternatives": ["MPI (Message Passing Interface)"], "explanation": "Message passing is a parallel programming model where processes communicate by explicitly sending and receiving messages. Each process has its own memory space, and data sharing requires explicit communication. MPI (Message Passing Interface) is the standard API for message passing in HPC."},
        {"question": "What is the term for uneven distribution of work among processors?", "answer": "Load imbalance", "alternatives": ["Work imbalance"], "explanation": "Load imbalance occurs when some processors have more work than others, causing them to finish at different times. This wastes processor cycles as some sit idle waiting for others. Effective load balancing, either static or dynamic, distributes work evenly to maximize utilization and minimize total execution time."},
        {"question": "What technique allows threads to share memory while executing independently?", "answer": "Shared memory multithreading", "alternatives": ["Thread-level parallelism"], "explanation": "Shared memory multithreading allows multiple threads within a process to share memory while executing independently on different cores. This simplifies data sharing compared to message passing but requires synchronization (locks, barriers) to prevent race conditions. OpenMP is a popular shared-memory parallel programming API."},
        {"question": "What barrier synchronization point ensures all threads reach a certain point before any can proceed?", "answer": "Barrier", "alternatives": ["Synchronization barrier"], "explanation": "A barrier is a synchronization point where threads must wait until all threads reach it before any can proceed past it. This ensures all threads complete one phase before starting the next. Barriers are useful for algorithms with distinct phases that depend on all processors completing previous work."},
        {"question": "What metric measures the fraction of time processors spend doing useful work versus waiting?", "answer": "Parallel efficiency", "alternatives": ["Utilization"], "explanation": "Parallel efficiency is the speedup divided by the number of processors, indicating how effectively processors are utilized. Perfect efficiency (100%) means linear speedup; lower efficiency indicates overhead, load imbalance, or insufficient parallelism. Maintaining high efficiency as processor count increases is a major challenge."},
        {"question": "What technique duplicates data across processors to reduce communication?", "answer": "Data replication", "alternatives": ["Redundant storage"], "explanation": "Data replication stores copies of data on multiple processors, reducing the need for remote access and communication. The tradeoff is increased memory usage and the need to maintain consistency if data is modified. Replication is effective for read-mostly data shared across many processors."},
        {"question": "What architecture connects processors in a grid where each can communicate with neighbors?", "answer": "Mesh topology", "alternatives": ["2D mesh", "Grid network"], "explanation": "Mesh topology arranges processors in a 2D (or 3D) grid where each processor connects to its neighbors. This provides good locality for many algorithms and scales well, though communication between distant processors requires multiple hops. Many-core processors and NoC (Network-on-Chip) designs use mesh topologies."}
    ],
    "difficult": [
        {"question": "What consistency model guarantees that operations appear to execute atomically in some sequential order?", "answer": "Sequential consistency", "alternatives": ["Sequential memory consistency"], "explanation": "Sequential consistency guarantees that the result of parallel execution is equivalent to some sequential interleaving of operations from all processors, with operations from each processor in program order. This is intuitive but expensive to implement, requiring synchronization that can hurt performance. Many systems use weaker models."},
        {"question": "What phenomenon causes performance degradation when multiple cores access the same cache line?", "answer": "False sharing", "alternatives": ["Cache line contention"], "explanation": "False sharing occurs when threads on different cores modify different variables that happen to reside in the same cache line. Even though there's no true data sharing, the cache coherence protocol causes invalidations and performance degradation. Padding variables to different cache lines avoids this."},
        {"question": "What lock-free synchronization technique allows threads to retry operations if conflicts occur?", "answer": "Optimistic concurrency", "alternatives": ["Transactional memory", "Compare-and-swap"], "explanation": "Optimistic concurrency assumes conflicts are rare and allows threads to proceed without locking. If a conflict is detected (via compare-and-swap or similar atomics), the operation retries. This can outperform locks when contention is low but may waste work under high contention. Software transactional memory is an advanced form."},
        {"question": "What technique overlaps computation with communication to hide latency?", "answer": "Latency hiding", "alternatives": ["Communication-computation overlap"], "explanation": "Latency hiding initiates communication asynchronously and performs other computation while waiting for data to arrive. This overlaps communication latency with useful work, improving efficiency. Pre-fetching and non-blocking communication primitives enable latency hiding, crucial for distributed memory systems where communication is expensive."},
        {"question": "What synchronization mechanism allows producers and consumers to communicate through a fixed-size buffer?", "answer": "Bounded buffer", "alternatives": ["Producer-consumer queue", "Ring buffer"], "explanation": "A bounded buffer (or circular buffer) is a fixed-size queue for producer-consumer communication. Producers add items; consumers remove them. Synchronization ensures producers wait when full and consumers wait when empty. This decouples producers and consumers, allowing them to run at different rates, improving parallelism."},
        {"question": "What advanced processor feature allows cores to temporarily use another core's resources?", "answer": "Resource sharing", "alternatives": ["Dynamic resource allocation"], "explanation": "Modern processors allow resource sharing where idle execution units from one core can be used by another core. This is beyond simple SMT - it's dynamic reallocation of functional units, cache capacity, or bandwidth based on workload needs. This improves utilization but adds complexity to resource management."},
        {"question": "What technique partitions data so that communication only occurs at partition boundaries?", "answer": "Domain decomposition", "alternatives": ["Spatial decomposition"], "explanation": "Domain decomposition partitions the problem domain (e.g., physical space in simulations) across processors. Each processor works on its partition, communicating only with neighbors at boundaries. This minimizes communication volume and is fundamental to parallel scientific computing, enabling massive-scale simulations."},
        {"question": "What memory consistency model only guarantees ordering for synchronization operations?", "answer": "Weak consistency", "alternatives": ["Weak ordering"], "explanation": "Weak consistency models relax ordering guarantees, requiring synchronization only at explicit synchronization points. Ordinary loads and stores can be reordered freely; only synchronization operations (like barriers or atomic operations) enforce ordering. This allows aggressive optimizations but requires careful programming. Most modern systems use weak models."},
        {"question": "What technique adjusts the number of threads dynamically based on available resources?", "answer": "Dynamic parallelism", "alternatives": ["Adaptive parallelism"], "explanation": "Dynamic parallelism adjusts thread count at runtime based on workload characteristics and available resources. For example, reducing threads when other applications compete for cores, or increasing threads for larger problem sizes. This adapts to varying conditions but adds runtime overhead for thread management."},
        {"question": "What protocol coordinates cache coherence in multiprocessor systems?", "answer": "Cache coherence protocol", "alternatives": ["MESI", "Snooping protocol", "Directory protocol"], "explanation": "Cache coherence protocols ensure all processors see a consistent view of memory when data is cached in multiple places. Snooping protocols (like MESI) broadcast cache operations; directory protocols maintain a central directory of cache contents. Coherence is essential for shared-memory multiprocessors but adds overhead that limits scalability."}
    ]
}

# Update the dictionary at the end
ALL_ADDITIONAL_QUESTIONS['parallel_processing'] = PARALLEL_PROCESSING_QUESTIONS

# 6. Cryptography
CRYPTOGRAPHY_QUESTIONS = {
    "easy": [
        {"question": "What is the practice of securing information by transforming it into an unreadable format?", "answer": "Encryption", "alternatives": ["Cryptographic encryption"], "explanation": "Encryption transforms plaintext (readable data) into ciphertext (unreadable data) using an algorithm and a key. Only those with the correct key can decrypt the ciphertext back to plaintext. Encryption protects data confidentiality during storage and transmission."},
        {"question": "What type of encryption uses the same key for both encryption and decryption?", "answer": "Symmetric encryption", "alternatives": ["Secret key encryption", "Symmetric key cryptography"], "explanation": "Symmetric encryption uses a single shared key for both encryption and decryption. It's fast and efficient for large data volumes but requires secure key distribution. Examples include AES, DES, and ChaCha20. The main challenge is securely sharing the key between parties."},
        {"question": "What encryption method uses two different but mathematically related keys?", "answer": "Asymmetric encryption", "alternatives": ["Public key encryption", "Public key cryptography"], "explanation": "Asymmetric encryption uses a key pair: a public key (shared openly) for encryption and a private key (kept secret) for decryption. Anyone can encrypt with the public key, but only the private key holder can decrypt. RSA and ECC are common asymmetric algorithms."},
        {"question": "What fixed-size value represents data that has been processed through a hash function?", "answer": "Hash", "alternatives": ["Hash value", "Digest", "Checksum"], "explanation": "A hash (or digest) is a fixed-size output from a hash function that uniquely represents input data. Good hash functions are one-way (can't reverse to find input) and collision-resistant (different inputs produce different hashes). Common uses include password storage and data integrity verification."},
        {"question": "What key in public key cryptography can be freely shared with anyone?", "answer": "Public key", "alternatives": ["Public encryption key"], "explanation": "The public key in asymmetric cryptography can be freely distributed to anyone. Data encrypted with a public key can only be decrypted with the corresponding private key. This solves the key distribution problem of symmetric encryption and enables applications like secure email and HTTPS."},
        {"question": "What is the process of converting ciphertext back into readable plaintext?", "answer": "Decryption", "alternatives": ["Deciphering"], "explanation": "Decryption is the reverse of encryption - converting ciphertext back to its original plaintext form using the appropriate key and algorithm. In symmetric encryption, the same key encrypts and decrypts. In asymmetric encryption, the private key decrypts data encrypted with the public key."},
        {"question": "What technique protects passwords by storing only their hash values?", "answer": "Password hashing", "alternatives": ["Cryptographic hashing"], "explanation": "Password hashing stores only the hash of passwords, not the passwords themselves. When users log in, their entered password is hashed and compared to the stored hash. Even if the database is compromised, attackers only get hashes, not actual passwords. Salt (random data added before hashing) prevents rainbow table attacks."},
        {"question": "What cryptographic technique combines symmetric and asymmetric encryption for efficiency?", "answer": "Hybrid encryption", "alternatives": ["Hybrid cryptography"], "explanation": "Hybrid encryption uses asymmetric encryption to exchange a symmetric key, then uses that symmetric key for bulk data encryption. This combines the security of public key cryptography with the speed of symmetric encryption. HTTPS/TLS uses hybrid encryption."},
        {"question": "What algorithm is the current standard for symmetric encryption approved by NIST?", "answer": "AES", "alternatives": ["Advanced Encryption Standard", "AES encryption"], "explanation": "AES (Advanced Encryption Standard) is the current standard for symmetric encryption, adopted by NIST in 2001. It replaced DES and offers 128, 192, or 256-bit key sizes. AES is fast, secure, and widely implemented in hardware and software, used in everything from file encryption to VPNs."},
        {"question": "What is the secret piece of information used to encrypt or decrypt data?", "answer": "Key", "alternatives": ["Encryption key", "Cryptographic key"], "explanation": "A key is secret information (typically a string of bits) used by cryptographic algorithms to encrypt and decrypt data. Key strength (length and randomness) determines encryption security. Longer keys provide more security but may require more computation. Key management (generation, distribution, storage) is critical for system security."}
    ],
    "average": [
        {"question": "What attack tries all possible keys until finding the correct one?", "answer": "Brute force attack", "alternatives": ["Exhaustive key search"], "explanation": "A brute force attack systematically tries every possible key until finding one that decrypts the data correctly. Modern encryption uses key sizes large enough to make brute force computationally infeasible - AES-256 would require astronomical time even with all world's computing power. This is why key length is crucial for security."},
        {"question": "What cryptographic primitive ensures data has not been modified?", "answer": "Message Authentication Code", "alternatives": ["MAC", "HMAC"], "explanation": "A Message Authentication Code (MAC) is a tag computed from a message and a secret key, ensuring both integrity (data hasn't been modified) and authenticity (message came from someone with the key). HMAC (Hash-based MAC) is a common construction using hash functions. MACs detect tampering and forgery."},
        {"question": "What method adds random data to passwords before hashing to prevent rainbow table attacks?", "answer": "Salting", "alternatives": ["Salt"], "explanation": "Salting adds random data (salt) to each password before hashing. Even identical passwords have different hashes due to unique salts. This defeats precomputed rainbow tables since attackers must recompute hashes for each salt. Salt is stored with the hash and doesn't need to be secret, just unique and random."},
        {"question": "What public key cryptography algorithm is based on the difficulty of factoring large numbers?", "answer": "RSA", "alternatives": ["RSA encryption"], "explanation": "RSA (Rivest-Shamir-Adleman) is based on the difficulty of factoring the product of two large prime numbers. It's widely used for secure data transmission and digital signatures. While secure with sufficient key size (2048+ bits), RSA is computationally expensive compared to symmetric encryption, hence its use in hybrid schemes."},
        {"question": "What cryptographic technique allows verification of a message's sender without revealing their identity?", "answer": "Digital signature", "alternatives": ["Digital signing"], "explanation": "Digital signatures use asymmetric cryptography to verify message authenticity and integrity. The sender signs with their private key; anyone with the public key can verify. Unlike MACs, signatures provide non-repudiation - the signer can't deny creating the signature. Digital signatures are fundamental to PKI and secure communications."},
        {"question": "What attack exploits weaknesses in cryptographic implementation rather than the algorithm itself?", "answer": "Side-channel attack", "alternatives": ["Timing attack"], "explanation": "Side-channel attacks exploit information leaked during cryptographic operations - timing variations, power consumption, electromagnetic emissions, or acoustic signals. For example, timing attacks measure how long decryption takes to deduce information about the key. Constant-time implementations and other countermeasures defend against side-channels."},
        {"question": "What protocol establishes secure communication by negotiating encryption parameters?", "answer": "Key exchange protocol", "alternatives": ["Key agreement"], "explanation": "Key exchange protocols allow two parties to establish a shared secret key over an insecure channel. Diffie-Hellman is the classic example. Even if an attacker observes all communication, they can't determine the shared key. Key exchange is fundamental to protocols like TLS/SSL."},
        {"question": "What cryptographic concept ensures a sender cannot deny sending a message?", "answer": "Non-repudiation", "alternatives": ["Non-denial"], "explanation": "Non-repudiation prevents a sender from denying they sent a message. Digital signatures provide non-repudiation - the signature can only be created with the private key, proving the signer had that key. This is crucial for legal and financial applications where proof of origin is required."},
        {"question": "What type of cipher encrypts data one bit or byte at a time in a continuous stream?", "answer": "Stream cipher", "alternatives": ["Streaming encryption"], "explanation": "Stream ciphers encrypt data as a continuous stream, typically one byte or bit at a time using a keystream. They're fast and have no padding requirements, ideal for real-time communication. ChaCha20 and RC4 (now deprecated) are stream ciphers. They contrast with block ciphers that process fixed-size blocks."},
        {"question": "What infrastructure manages public keys and digital certificates?", "answer": "PKI (Public Key Infrastructure)", "alternatives": ["Public Key Infrastructure"], "explanation": "PKI is a framework for managing public key cryptography, including certificate authorities (CAs), registration authorities, and certificate repositories. PKI enables secure communication between parties who've never met by having trusted CAs vouch for key ownership through digital certificates. The web's HTTPS relies on PKI."}
    ],
    "difficult": [
        {"question": "What advanced cryptographic technique allows computations on encrypted data without decrypting it?", "answer": "Homomorphic encryption", "alternatives": ["FHE", "Fully homomorphic encryption"], "explanation": "Homomorphic encryption allows operations on encrypted data that produce encrypted results matching operations on plaintext. Fully homomorphic encryption (FHE) supports arbitrary computations, enabling cloud computing on sensitive data without exposing it. While theoretically revolutionary, FHE remains computationally expensive despite recent advances."},
        {"question": "What attack recovers plaintext by finding two inputs that produce the same hash?", "answer": "Collision attack", "alternatives": ["Hash collision"], "explanation": "Collision attacks find two different inputs producing the same hash output. If successful against a cryptographic hash, this breaks integrity guarantees. MD5 and SHA-1 have known collision attacks and are deprecated. Modern hashes like SHA-256 and SHA-3 resist collision attacks with sufficient output size."},
        {"question": "What cryptographic mode combines encryption with authentication in a single operation?", "answer": "Authenticated encryption", "alternatives": ["AEAD", "Authenticated Encryption with Associated Data", "GCM"], "explanation": "Authenticated Encryption with Associated Data (AEAD) provides both confidentiality and authenticity in one operation. GCM (Galois/Counter Mode) and ChaCha20-Poly1305 are popular AEAD modes. They're more efficient and secure than combining separate encryption and MAC operations, preventing subtle implementation vulnerabilities like padding oracle attacks."},
        {"question": "What mathematical problem underlies elliptic curve cryptography's security?", "answer": "Discrete logarithm problem", "alternatives": ["Elliptic curve discrete logarithm", "ECDLP"], "explanation": "Elliptic Curve Cryptography (ECC) security relies on the difficulty of the elliptic curve discrete logarithm problem. ECC achieves equivalent security to RSA with much shorter keys - 256-bit ECC equals 3072-bit RSA. This makes ECC efficient for resource-constrained environments like mobile devices and IoT, explaining its growing adoption."},
        {"question": "What cryptographic technique allows proving knowledge of a secret without revealing the secret itself?", "answer": "Zero-knowledge proof", "alternatives": ["ZKP", "Zero-knowledge protocol"], "explanation": "Zero-knowledge proofs allow one party (prover) to convince another (verifier) they know a secret without revealing the secret itself. This seems paradoxical but is mathematically rigorous. Applications include privacy-preserving authentication and cryptocurrencies. zk-SNARKs and zk-STARKs are advanced zero-knowledge constructions."},
        {"question": "What attack exploits mathematical relationships between plaintext, ciphertext, and keys?", "answer": "Cryptanalysis", "alternatives": ["Cryptanalytic attack"], "explanation": "Cryptanalysis is the science of breaking cryptographic systems through mathematical analysis rather than brute force. Techniques include differential cryptanalysis (analyzing how differences in input affect output), linear cryptanalysis (finding linear approximations), and algebraic attacks. Modern ciphers are designed to resist known cryptanalytic attacks."},
        {"question": "What protocol allows two parties to agree on a shared secret without prior communication?", "answer": "Diffie-Hellman key exchange", "alternatives": ["Diffie-Hellman", "DH key exchange"], "explanation": "Diffie-Hellman enables two parties to establish a shared secret over an insecure channel with no prior shared secrets. Its security relies on the discrete logarithm problem. While not providing authentication (vulnerable to man-in-the-middle without additional measures), DH is fundamental to TLS and VPNs."},
        {"question": "What quantum computing algorithm threatens current public key cryptography?", "answer": "Shor's algorithm", "alternatives": ["Shor"], "explanation": "Shor's algorithm allows quantum computers to factor large numbers and solve discrete logarithms efficiently, breaking RSA and ECC. While large-scale quantum computers don't yet exist, their potential has driven development of post-quantum cryptography - algorithms resistant to both classical and quantum attacks, like lattice-based and hash-based schemes."},
        {"question": "What technique derives multiple keys from a single master secret?", "answer": "Key derivation function", "alternatives": ["KDF"], "explanation": "Key Derivation Functions (KDFs) generate one or more cryptographic keys from a secret value like a password or master key. PBKDF2, bcrypt, scrypt, and Argon2 are KDFs designed for password hashing, using iteration and memory-hardness to slow brute force attacks. Other KDFs like HKDF expand keys for protocol use."},
        {"question": "What mode of operation turns a block cipher into a stream cipher using XOR with keystream?", "answer": "Counter mode", "alternatives": ["CTR mode", "CTR"], "explanation": "Counter (CTR) mode encrypts a counter value with the block cipher to generate a keystream, which is XORed with plaintext. This turns block ciphers like AES into stream ciphers, enabling parallel encryption/decryption and random access. CTR is faster and more flexible than CBC mode and is used in modern protocols like GCM."}
    ]
}

# Continue with additional_questions.py updates
ALL_ADDITIONAL_QUESTIONS['cryptography'] = CRYPTOGRAPHY_QUESTIONS

# 7. Authentication
AUTHENTICATION_QUESTIONS = {
    "easy": [
        {"question": "What is the process of verifying the identity of a user or system?", "answer": "Authentication", "alternatives": ["User authentication", "Identity verification"], "explanation": "Authentication is the process of confirming that someone or something is who or what they claim to be. This typically involves checking credentials like passwords, fingerprints, or security tokens against stored information. Authentication is the first step in access control, followed by authorization."},
        {"question": "What is the most common type of authentication that uses a secret string known only to the user?", "answer": "Password", "alternatives": ["Password authentication"], "explanation": "Passwords are the most widely used authentication method. Users create a secret string that only they know, which is verified during login. While convenient, passwords have vulnerabilities including weak choices, reuse, and susceptibility to various attacks, leading to the adoption of stronger authentication methods."},
        {"question": "What authentication method uses physical characteristics unique to an individual?", "answer": "Biometric authentication", "alternatives": ["Biometrics"], "explanation": "Biometric authentication uses unique physical characteristics like fingerprints, facial recognition, iris scans, or voice patterns to verify identity. These characteristics are difficult to forge or steal, making biometrics more secure than passwords. However, they raise privacy concerns and can't be changed if compromised."},
        {"question": "What is the term for requiring two different forms of identification to verify a user?", "answer": "Two-factor authentication", "alternatives": ["2FA", "Multi-factor authentication", "MFA"], "explanation": "Two-factor authentication (2FA) requires two different types of credentials to verify identity, typically combining something you know (password), something you have (phone/token), or something you are (biometric). This significantly improves security because compromising one factor isn't enough to gain access."},
        {"question": "What type of authentication uses a physical device that generates time-based codes?", "answer": "Hardware token", "alternatives": ["Security token", "Authentication token"], "explanation": "Hardware tokens are physical devices that generate one-time passwords (OTP) or codes for authentication. They can be key fobs displaying changing numbers or USB devices. Hardware tokens are more secure than SMS-based 2FA because they're not vulnerable to SIM swapping or network attacks."},
        {"question": "What authentication factor involves something the user possesses?", "answer": "Possession factor", "alternatives": ["Something you have"], "explanation": "The possession factor ('something you have') includes physical objects like security tokens, smart cards, mobile phones, or key fobs. This is commonly used in multi-factor authentication combined with knowledge factors (passwords) to strengthen security by requiring both knowledge and physical possession."},
        {"question": "What is the authentication method where users log in once and gain access to multiple systems?", "answer": "Single Sign-On", "alternatives": ["SSO"], "explanation": "Single Sign-On (SSO) allows users to authenticate once and access multiple applications or systems without re-entering credentials. This improves user experience and can enhance security by reducing password fatigue and allowing centralized access control. Examples include logging into multiple Google services with one account."},
        {"question": "What temporary, time-sensitive code is used for one authentication session?", "answer": "One-time password", "alternatives": ["OTP", "One-time code"], "explanation": "One-time passwords (OTP) are temporary codes valid for a single login session or transaction. They're typically generated by authenticator apps or hardware tokens and expire quickly (often 30-60 seconds). OTPs prevent replay attacks since each code can only be used once."},
        {"question": "What authentication factor involves something the user knows?", "answer": "Knowledge factor", "alternatives": ["Something you know"], "explanation": "The knowledge factor ('something you know') includes information only the user should know, such as passwords, PINs, security questions, or passphrases. This is the most common authentication factor but is vulnerable to guessing, phishing, and social engineering if not properly protected."},
        {"question": "What is the process of granting or denying specific access rights after successful authentication?", "answer": "Authorization", "alternatives": ["Access control"], "explanation": "Authorization determines what an authenticated user is allowed to do. While authentication verifies identity, authorization specifies permissions and access levels. For example, after logging in (authentication), a user may be authorized to read files but not delete them. These are distinct but related security concepts."}
    ],
    "average": [
        {"question": "What protocol allows authentication across different domains using security tokens?", "answer": "SAML", "alternatives": ["Security Assertion Markup Language"], "explanation": "SAML (Security Assertion Markup Language) is an XML-based protocol for exchanging authentication and authorization data between identity providers and service providers. It enables SSO across different domains and is widely used in enterprise environments for federated authentication."},
        {"question": "What attack involves trying many passwords rapidly until finding the correct one?", "answer": "Brute force attack", "alternatives": ["Password brute force"], "explanation": "Brute force attacks systematically try all possible password combinations until finding the correct one. Defense mechanisms include account lockouts after failed attempts, rate limiting, CAPTCHAs, and requiring strong passwords. The attack's effectiveness decreases exponentially with password length and complexity."},
        {"question": "What authentication method uses cryptographic keys instead of passwords?", "answer": "Public key authentication", "alternatives": ["PKI authentication", "Certificate-based authentication"], "explanation": "Public key authentication uses asymmetric cryptography where users possess a private key and share a public key. The system verifies identity by checking if the user possesses the private key corresponding to the registered public key. This is more secure than passwords and is used in SSH, SSL/TLS certificates, and digital signatures."},
        {"question": "What attack tricks users into revealing their credentials by impersonating legitimate services?", "answer": "Phishing", "alternatives": ["Phishing attack"], "explanation": "Phishing is a social engineering attack where attackers impersonate trusted entities (banks, companies, colleagues) to trick victims into revealing credentials or sensitive information. Common vectors include emails, fake websites, and text messages. Education, email filtering, and multi-factor authentication help defend against phishing."},
        {"question": "What standard describes time-based one-time passwords using HMAC?", "answer": "TOTP", "alternatives": ["Time-based One-Time Password"], "explanation": "TOTP (Time-based One-Time Password) is an algorithm that generates one-time passwords using the current time and a shared secret key. The code changes every 30 seconds, making it secure against replay attacks. Google Authenticator and similar apps implement TOTP for 2FA."},
        {"question": "What OAuth flow is used for server-side web applications to obtain access tokens?", "answer": "Authorization Code flow", "alternatives": ["Authorization Code grant"], "explanation": "The Authorization Code flow is OAuth 2.0's most secure flow for server-side applications. Users authenticate with the authorization server, which redirects back with a code. The application exchanges this code for an access token server-to-server, keeping tokens secure on the backend. This prevents token exposure to browsers."},
        {"question": "What attack exploits weakly hashed passwords using precomputed tables?", "answer": "Rainbow table attack", "alternatives": ["Rainbow table"], "explanation": "Rainbow table attacks use precomputed tables of password hashes to quickly crack hashed passwords. Attackers compare stolen hashes against the rainbow table to find matching passwords. Salting (adding random data before hashing) defeats rainbow tables by making each hash unique, requiring attackers to recompute tables for each salt."},
        {"question": "What authentication mechanism uses a centralized server to validate credentials in large networks?", "answer": "RADIUS", "alternatives": ["Remote Authentication Dial-In User Service"], "explanation": "RADIUS (Remote Authentication Dial-In User Service) is a networking protocol providing centralized authentication, authorization, and accounting (AAA) for network access. It's commonly used for WiFi networks, VPNs, and ISP access, allowing centralized user management and policy enforcement across distributed systems."},
        {"question": "What newer authentication protocol provides better security than RADIUS with modern encryption?", "answer": "DIAMETER", "alternatives": ["DIAMETER protocol"], "explanation": "DIAMETER is the successor to RADIUS, designed for modern networks with improved security (mandatory encryption), reliability (TCP/SCTP instead of UDP), and capability negotiation. Despite the name, DIAMETER isn't exactly twice as good as RADIUS - the name is a play on words. It's used in mobile networks and IMS."},
        {"question": "What attack captures authentication tokens to replay them and gain unauthorized access?", "answer": "Session hijacking", "alternatives": ["Session replay attack", "Cookie hijacking"], "explanation": "Session hijacking occurs when an attacker captures or predicts a valid session token to impersonate an authenticated user. Methods include network sniffing, XSS attacks, or session fixation. Defenses include HTTPS encryption, secure cookie flags, short session timeouts, and binding sessions to IP addresses or user agents."}
    ],
    "difficult": [
        {"question": "What challenge-response protocol uses a cryptographic hash to authenticate without sending passwords?", "answer": "CHAP", "alternatives": ["Challenge Handshake Authentication Protocol"], "explanation": "CHAP (Challenge Handshake Authentication Protocol) authenticates users without transmitting passwords over the network. The server sends a random challenge, the client hashes it with their password, and sends the hash back. The server verifies by computing the same hash. This prevents password interception and replay attacks."},
        {"question": "What authentication framework enables passwordless login using biometrics and public key cryptography?", "answer": "FIDO2", "alternatives": ["WebAuthn", "Fast Identity Online 2"], "explanation": "FIDO2 is a modern authentication standard comprising WebAuthn (browser API) and CTAP (communication protocol). It enables passwordless authentication using biometrics, PINs, or hardware tokens with public key cryptography. Each site gets unique credentials, preventing phishing and credential stuffing. Major platforms now support FIDO2."},
        {"question": "What Kerberos component issues tickets for authentication in Windows domains?", "answer": "Key Distribution Center", "alternatives": ["KDC"], "explanation": "The Key Distribution Center (KDC) is the central component of Kerberos authentication, consisting of the Authentication Server (AS) and Ticket Granting Server (TGS). It issues encrypted tickets that prove user identity to services without repeatedly transmitting passwords. Kerberos is the foundation of Windows Active Directory authentication."},
        {"question": "What OAuth 2.0 extension adds authentication on top of the authorization framework?", "answer": "OpenID Connect", "alternatives": ["OIDC"], "explanation": "OpenID Connect (OIDC) is an identity layer built on OAuth 2.0, adding authentication to OAuth's authorization capabilities. It introduces ID tokens (JWT format) containing user identity claims, standardized user info endpoints, and discovery mechanisms. OIDC enables SSO and is widely used for social login and enterprise authentication."},
        {"question": "What attack bypasses authentication by manipulating the order or timing of authentication steps?", "answer": "Authentication bypass", "alternatives": ["Auth bypass", "Logic flaw"], "explanation": "Authentication bypass exploits logic flaws in authentication implementations, allowing attackers to access resources without proper credentials. Examples include skipping authentication checks, manipulating session states, exploiting race conditions, or leveraging default credentials. Preventing these requires secure coding practices, thorough testing, and security audits."},
        {"question": "What cryptographic protocol provides mutual authentication and key exchange for TLS?", "answer": "TLS handshake", "alternatives": ["Transport Layer Security handshake"], "explanation": "The TLS handshake establishes secure communication by performing mutual authentication (optionally), negotiating cipher suites, and exchanging keys. It uses asymmetric cryptography to securely exchange a symmetric session key. Modern TLS 1.3 improves performance with fewer round trips while maintaining security through authenticated encryption."},
        {"question": "What zero-knowledge proof protocol allows authentication without revealing passwords?", "answer": "Zero-knowledge password proof", "alternatives": ["ZKPP", "SRP", "Secure Remote Password"], "explanation": "Zero-knowledge password proofs (like SRP - Secure Remote Password protocol) allow users to prove they know a password without transmitting it or any information that could be used to derive it. Even the server doesn't store the password, only a verifier. This protects against server compromise and network eavesdropping."},
        {"question": "What attack exploits weak entropy in token generation to predict valid session tokens?", "answer": "Session prediction", "alternatives": ["Token prediction attack"], "explanation": "Session prediction attacks exploit weak randomness in session token generation. If tokens are predictable (sequential, weak PRNG, insufficient entropy), attackers can guess valid tokens and hijack sessions. Defense requires cryptographically secure random number generators (CSRNG) and sufficient token length to make brute force infeasible."},
        {"question": "What authentication mechanism allows services to authenticate users on behalf of other services without sharing credentials?", "answer": "Delegated authentication", "alternatives": ["OAuth delegation", "Trusted third-party authentication"], "explanation": "Delegated authentication allows users to grant third-party applications limited access to their resources without sharing credentials. OAuth 2.0 implements this through access tokens with defined scopes. Users authenticate with the identity provider, which issues tokens to third-party apps. This is fundamental to modern API security and social login."},
        {"question": "What technique binds authentication tokens to specific devices using hardware identifiers?", "answer": "Device fingerprinting", "alternatives": ["Hardware binding", "Device binding"], "explanation": "Device fingerprinting creates unique identifiers from device characteristics (OS, browser, screen resolution, hardware IDs, installed fonts) to bind authentication sessions to specific devices. This detects token theft and account takeover. However, advanced fingerprinting raises privacy concerns and can sometimes be circumvented by sophisticated attackers spoofing device characteristics."}
    ]
}

ALL_ADDITIONAL_QUESTIONS['authentication'] = AUTHENTICATION_QUESTIONS

# 8. Security Threats
SECURITY_THREATS_QUESTIONS = {
    "easy": [
        {"question": "What malicious software is designed to damage, disrupt, or gain unauthorized access to a computer system?", "answer": "Malware", "alternatives": ["Malicious software"], "explanation": "Malware is an umbrella term for any software intentionally designed to cause harm. Types include viruses, worms, trojans, ransomware, spyware, and adware. Malware can steal data, encrypt files for ransom, consume resources, or provide backdoor access to attackers. Antivirus software and safe computing practices help prevent infections."},
        {"question": "What type of malware disguises itself as legitimate software to trick users into installing it?", "answer": "Trojan", "alternatives": ["Trojan horse"], "explanation": "Trojans (named after the Greek wooden horse) appear to be useful programs but contain hidden malicious functionality. Unlike viruses, trojans don't replicate themselves. They might disguise as games, utilities, or email attachments. Once installed, they can steal data, download additional malware, or create backdoors for remote access."},
        {"question": "What attack involves sending fraudulent communications that appear to come from a reputable source?", "answer": "Phishing", "alternatives": ["Phishing attack"], "explanation": "Phishing is a social engineering attack where attackers impersonate trusted entities through email, text messages, or fake websites to trick victims into revealing credentials, financial information, or installing malware. Spear phishing targets specific individuals with personalized attacks. Education and email filtering help combat phishing."},
        {"question": "What malicious software replicates itself and spreads to other computers without user intervention?", "answer": "Worm", "alternatives": ["Computer worm"], "explanation": "Worms are self-replicating malware that spread automatically across networks without user action. Unlike viruses (which require a host file), worms are standalone programs. They exploit vulnerabilities to propagate, consuming network bandwidth and system resources. Famous examples include Morris Worm, Code Red, and WannaCry."},
        {"question": "What attack overwhelms a system with traffic to make it unavailable to legitimate users?", "answer": "DoS attack", "alternatives": ["Denial of Service", "DDoS", "Denial of Service attack"], "explanation": "Denial of Service (DoS) attacks flood systems with excessive requests, consuming resources and preventing legitimate access. Distributed DoS (DDoS) attacks use many compromised computers (botnets) to amplify the attack. Defenses include rate limiting, traffic filtering, and DDoS protection services that absorb attack traffic."},
        {"question": "What type of malware encrypts files and demands payment for decryption?", "answer": "Ransomware", "alternatives": ["Crypto-ransomware"], "explanation": "Ransomware encrypts victim files or locks systems, demanding ransom (typically cryptocurrency) for the decryption key. Notable examples include WannaCry and CryptoLocker. Prevention includes regular backups, security updates, and email filtering. Paying ransom doesn't guarantee file recovery and encourages attackers."},
        {"question": "What vulnerability exploitation occurs before the software vendor is aware of it?", "answer": "Zero-day exploit", "alternatives": ["Zero-day attack", "0-day"], "explanation": "Zero-day exploits target previously unknown vulnerabilities before vendors can create patches. These are particularly dangerous because no defense exists yet. Attackers may discover these vulnerabilities themselves or purchase them on dark markets. Organizations use defense-in-depth strategies to limit zero-day impact."},
        {"question": "What attack intercepts communication between two parties without their knowledge?", "answer": "Man-in-the-middle attack", "alternatives": ["MITM", "Interception attack"], "explanation": "Man-in-the-middle (MITM) attacks occur when attackers secretly intercept and possibly alter communication between two parties who believe they're directly communicating. Attackers can eavesdrop or inject malicious content. HTTPS, VPNs, and certificate validation help prevent MITM attacks by ensuring communication authenticity and encryption."},
        {"question": "What malicious software secretly monitors and records user activity?", "answer": "Spyware", "alternatives": ["Surveillance software"], "explanation": "Spyware covertly monitors user activities, collecting sensitive information like passwords, browsing habits, credit card numbers, or keystrokes. It transmits this data to attackers without user knowledge. Keyloggers are a specific type of spyware recording keystrokes. Anti-malware software can detect and remove spyware."},
        {"question": "What social engineering attack involves creating a fabricated scenario to obtain information?", "answer": "Pretexting", "alternatives": ["Pretext attack"], "explanation": "Pretexting involves creating a fabricated scenario (pretext) to manipulate victims into divulging information or performing actions. Attackers might impersonate IT support, executives, or authorities to gain trust. Unlike phishing which uses deception, pretexting involves more elaborate interaction and storytelling. Training helps employees recognize and resist pretexting."}
    ],
    "average": [
        {"question": "What attack injects malicious code into web pages viewed by other users?", "answer": "Cross-site scripting", "alternatives": ["XSS", "XSS attack"], "explanation": "Cross-Site Scripting (XSS) occurs when attackers inject malicious JavaScript into web pages viewed by other users. The script executes in victims' browsers, potentially stealing session cookies, redirecting users, or defacing pages. Types include stored XSS (persistent), reflected XSS (one-time), and DOM-based XSS. Input validation and output encoding prevent XSS."},
        {"question": "What attack manipulates SQL queries by injecting malicious SQL code through user inputs?", "answer": "SQL injection", "alternatives": ["SQLi", "SQL injection attack"], "explanation": "SQL injection exploits vulnerable database queries by injecting malicious SQL code through user inputs. Attackers can bypass authentication, extract sensitive data, modify databases, or execute administrative operations. Parameterized queries (prepared statements) and input validation prevent SQL injection, one of the most common web vulnerabilities."},
        {"question": "What attack tricks authenticated users into executing unwanted actions on web applications?", "answer": "Cross-Site Request Forgery", "alternatives": ["CSRF", "XSRF"], "explanation": "CSRF attacks trick authenticated users into submitting malicious requests they didn't intend. Attackers craft requests (in emails or websites) that execute with the victim's authentication. For example, transferring funds or changing settings. Anti-CSRF tokens that validate request origin prevent these attacks."},
        {"question": "What type of attack exploits buffer overflows to execute arbitrary code?", "answer": "Buffer overflow attack", "alternatives": ["Buffer overflow"], "explanation": "Buffer overflow attacks occur when programs write more data to a buffer than it can hold, overwriting adjacent memory. Attackers exploit this to inject and execute malicious code, often gaining system privileges. Modern defenses include Address Space Layout Randomization (ASLR), Data Execution Prevention (DEP), and safe programming practices."},
        {"question": "What attack uses compromised computers to perform coordinated malicious activities?", "answer": "Botnet", "alternatives": ["Bot network", "Zombie network"], "explanation": "Botnets are networks of compromised computers (bots/zombies) controlled by attackers. They're used for DDoS attacks, spam distribution, credential theft, and cryptocurrency mining. Devices become bots through malware infections exploiting weak passwords or unpatched vulnerabilities. Botnet takedowns require coordinated law enforcement and industry efforts."},
        {"question": "What vulnerability allows attackers to include malicious files from remote servers?", "answer": "Remote File Inclusion", "alternatives": ["RFI"], "explanation": "Remote File Inclusion (RFI) occurs when applications dynamically include external files based on user input without proper validation. Attackers can force the application to include malicious files from their servers, leading to code execution. Disabling remote file inclusion features and validating file paths prevents RFI attacks."},
        {"question": "What attack exploits race conditions between checking and using resources?", "answer": "Time-of-check to time-of-use", "alternatives": ["TOCTOU", "Race condition attack"], "explanation": "TOCTOU attacks exploit the time gap between checking a resource's state and using it. If the resource changes between check and use, attackers can manipulate the outcome. Examples include file system races where permissions change after checking but before access. Atomic operations and proper locking mechanisms prevent TOCTOU vulnerabilities."},
        {"question": "What social engineering attack involves searching through trash for valuable information?", "answer": "Dumpster diving", "alternatives": ["Trash diving"], "explanation": "Dumpster diving involves physically searching through an organization's trash for sensitive documents, printouts, or storage media containing passwords, proprietary information, or personal data. It's surprisingly effective when organizations don't properly dispose of sensitive materials. Secure document destruction (shredding) and data wiping prevent information leakage through dumpster diving."},
        {"question": "What attack follows authorized persons into restricted areas without proper authentication?", "answer": "Tailgating", "alternatives": ["Piggybacking"], "explanation": "Tailgating (or piggybacking) is a physical security breach where unauthorized individuals follow authorized persons through secure entry points. Attackers might pose as delivery personnel or pretend to have forgotten badges. Security awareness training, mantrap doors, and strict badge policies prevent tailgating."},
        {"question": "What attack involves eavesdropping on wireless network communications?", "answer": "Packet sniffing", "alternatives": ["Network sniffing", "Eavesdropping"], "explanation": "Packet sniffing captures network traffic to analyze or steal transmitted data. On unencrypted networks, attackers can intercept passwords, emails, and sensitive information. Tools like Wireshark perform legitimate sniffing for troubleshooting, but attackers misuse them for espionage. Encryption (HTTPS, VPNs) protects against sniffing."}
    ],
    "difficult": [
        {"question": "What advanced persistent threat involves long-term covert access for espionage or sabotage?", "answer": "APT", "alternatives": ["Advanced Persistent Threat"], "explanation": "Advanced Persistent Threats (APTs) are sophisticated, long-term attacks typically by nation-states or well-funded groups targeting specific organizations for espionage, intellectual property theft, or sabotage. APTs use multiple techniques, maintain persistence, and operate covertly for months or years. Detection requires behavioral analysis, threat intelligence, and comprehensive security monitoring."},
        {"question": "What attack exploits the trust relationship between websites to hijack user clicks?", "answer": "Clickjacking", "alternatives": ["UI redress attack"], "explanation": "Clickjacking tricks users into clicking hidden elements by overlaying invisible or disguised frames over legitimate content. Users think they're clicking one thing but actually interact with malicious content. This can lead to unintended actions like enabling webcam access or transferring funds. X-Frame-Options headers and Content Security Policy prevent clickjacking."},
        {"question": "What side-channel attack exploits CPU speculative execution to leak sensitive data?", "answer": "Spectre", "alternatives": ["Spectre attack"], "explanation": "Spectre exploits speculative execution in modern CPUs to leak sensitive data across security boundaries. It tricks the CPU into speculatively executing instructions that shouldn't be executed, then uses timing attacks to extract information left in cache. Spectre is difficult to mitigate completely, requiring software patches, microcode updates, and sometimes performance penalties."},
        {"question": "What attack manipulates DNS responses to redirect users to malicious sites?", "answer": "DNS poisoning", "alternatives": ["DNS cache poisoning", "DNS spoofing"], "explanation": "DNS poisoning corrupts DNS cache data, causing name servers to return incorrect IP addresses. Users attempting to access legitimate sites are redirected to malicious ones that may look identical but steal credentials or distribute malware. DNSSEC (DNS Security Extensions) cryptographically validates DNS responses to prevent poisoning."},
        {"question": "What attack exploits deserialization of untrusted data to execute arbitrary code?", "answer": "Insecure deserialization", "alternatives": ["Deserialization attack"], "explanation": "Insecure deserialization occurs when applications deserialize untrusted data without validation, potentially allowing remote code execution. Attackers craft malicious serialized objects that, when deserialized, execute arbitrary code or manipulate application logic. This was added to OWASP Top 10 due to its severity. Avoid deserializing untrusted data or use safe alternatives like JSON."},
        {"question": "What attack compromises legitimate websites to distribute malware to visitors?", "answer": "Watering hole attack", "alternatives": ["Watering hole"], "explanation": "Watering hole attacks compromise websites frequently visited by target victims (like industry forums or news sites), then use these sites to distribute malware. Rather than attacking targets directly, attackers infect sites targets trust and visit regularly. This is common in targeted espionage. Browser security, ad blockers, and endpoint protection provide defense."},
        {"question": "What technique allows attackers to extract cryptographic keys through power consumption analysis?", "answer": "Power analysis attack", "alternatives": ["Differential power analysis", "DPA"], "explanation": "Power analysis attacks extract cryptographic keys by analyzing a device's power consumption during cryptographic operations. Differential Power Analysis (DPA) uses statistical methods to reveal secret keys from power traces. This is a side-channel attack particularly effective against embedded devices and smart cards. Countermeasures include random delays and power consumption masking."},
        {"question": "What attack manipulates return addresses on the stack to execute attacker-controlled code?", "answer": "Return-oriented programming", "alternatives": ["ROP", "ROP attack"], "explanation": "Return-Oriented Programming (ROP) chains together existing code snippets (gadgets) ending in return instructions to perform arbitrary operations, bypassing Data Execution Prevention (DEP). Attackers don't inject new code but reuse existing executable code in creative sequences. Control-Flow Integrity (CFI) and stack cookies help defend against ROP attacks."},
        {"question": "What attack forces users to perform actions by hiding commands in trusted media?", "answer": "Confused deputy attack", "alternatives": ["Confused deputy"], "explanation": "Confused deputy attacks exploit programs with excessive privileges that can be tricked into misusing their authority. The program (deputy) is confused into performing actions on behalf of an attacker that it shouldn't authorize. This is a privilege escalation technique. Principle of least privilege and careful privilege design prevent confused deputy vulnerabilities."},
        {"question": "What attack exfiltrates data by encoding it in DNS queries to bypass firewalls?", "answer": "DNS tunneling", "alternatives": ["DNS exfiltration"], "explanation": "DNS tunneling encodes data within DNS queries and responses, creating a covert communication channel that bypasses firewalls and security controls since DNS is typically allowed. Attackers exfiltrate data or establish C2 (command and control) channels through DNS. Detection requires analyzing DNS query patterns, frequency, and payload sizes for anomalies."}
    ]
}

ALL_ADDITIONAL_QUESTIONS['security_threats'] = SECURITY_THREATS_QUESTIONS

# 9. Security Protocols
SECURITY_PROTOCOLS_QUESTIONS = {
    "easy": [
        {"question": "What protocol secures web communications by encrypting data between browsers and servers?", "answer": "HTTPS", "alternatives": ["HTTP Secure", "SSL/TLS"], "explanation": "HTTPS (HTTP Secure) encrypts web traffic using SSL/TLS protocols, protecting data from eavesdropping and tampering. The padlock icon in browsers indicates HTTPS is active. It's essential for protecting sensitive information like passwords and financial data. HTTPS has become standard for all websites, not just those handling sensitive data."},
        {"question": "What security protocol encrypts data transmitted over wireless networks?", "answer": "WPA2", "alternatives": ["WPA3", "WiFi Protected Access"], "explanation": "WPA2 (WiFi Protected Access 2) secures wireless networks using AES encryption. It replaced the vulnerable WEP protocol. WPA3, the latest version, offers enhanced security including protection against brute force attacks and forward secrecy. Using strong passwords and WPA2/WPA3 is essential for WiFi security."},
        {"question": "What protocol creates an encrypted tunnel for secure remote access over public networks?", "answer": "VPN", "alternatives": ["Virtual Private Network"], "explanation": "VPNs (Virtual Private Networks) create encrypted tunnels between devices and networks over the internet, protecting data from interception. They're used for secure remote access to corporate networks, privacy protection, and bypassing geographic restrictions. Common VPN protocols include OpenVPN, IPsec, and WireGuard."},
        {"question": "What protocol secures email transmission between mail servers?", "answer": "TLS", "alternatives": ["Transport Layer Security", "STARTTLS"], "explanation": "TLS (Transport Layer Security) secures various internet protocols including email (SMTP with STARTTLS). It provides encryption, authentication, and integrity for data in transit. TLS 1.2 and 1.3 are current standards, with older versions like SSL 3.0 and TLS 1.0 being deprecated due to vulnerabilities."},
        {"question": "What protocol provides secure remote command-line access to servers?", "answer": "SSH", "alternatives": ["Secure Shell"], "explanation": "SSH (Secure Shell) provides encrypted remote access to systems, replacing insecure Telnet. It supports secure file transfer (SCP, SFTP), port forwarding, and key-based authentication. SSH uses public key cryptography for authentication and symmetric encryption for data transfer. It's fundamental for system administration."},
        {"question": "What security layer was replaced by the more secure TLS protocol?", "answer": "SSL", "alternatives": ["Secure Sockets Layer"], "explanation": "SSL (Secure Sockets Layer) was the predecessor to TLS. SSL 2.0 and 3.0 have known vulnerabilities and are now deprecated. While people still say 'SSL certificates' or 'SSL/TLS', modern systems actually use TLS. The term persists due to historical naming, but TLS 1.2 and 1.3 are the secure standards."},
        {"question": "What protocol secures file transfers by encrypting data during transmission?", "answer": "SFTP", "alternatives": ["SSH File Transfer Protocol", "Secure FTP"], "explanation": "SFTP (SSH File Transfer Protocol) provides secure file transfer over SSH, encrypting both commands and data. It's different from FTPS (FTP over SSL/TLS). SFTP is preferred for secure file transfers because it uses a single port and integrates with SSH authentication. It replaces insecure FTP for sensitive data."},
        {"question": "What protocol authenticates and encrypts VPN connections using certificates?", "answer": "IPsec", "alternatives": ["IP Security"], "explanation": "IPsec (Internet Protocol Security) authenticates and encrypts IP packets, commonly used in VPNs for site-to-site and remote access connections. It operates at the network layer, providing security for all applications. IPsec can use AH (Authentication Header) for integrity or ESP (Encapsulating Security Payload) for encryption and integrity."},
        {"question": "What protocol ensures DNS responses are authentic and unmodified?", "answer": "DNSSEC", "alternatives": ["DNS Security Extensions"], "explanation": "DNSSEC (DNS Security Extensions) adds cryptographic signatures to DNS records, allowing verification that responses are authentic and haven't been tampered with. This prevents DNS poisoning and man-in-the-middle attacks. DNSSEC uses public key cryptography to create a chain of trust from root DNS servers down to individual domains."},
        {"question": "What protocol family secures electronic mail end-to-end?", "answer": "PGP", "alternatives": ["Pretty Good Privacy", "GPG", "GnuPG"], "explanation": "PGP (Pretty Good Privacy) and its open-source implementation GPG (GNU Privacy Guard) provide end-to-end email encryption using public key cryptography. Senders encrypt with recipients' public keys; only recipients can decrypt with their private keys. PGP also provides digital signatures for authentication and integrity."}
    ],
    "average": [
        {"question": "What TLS handshake phase negotiates cipher suites and exchanges keys?", "answer": "TLS handshake", "alternatives": ["SSL handshake"], "explanation": "The TLS handshake establishes secure connections by negotiating protocol version, cipher suites, and authentication. It exchanges keys for symmetric encryption and verifies server (and optionally client) certificates. TLS 1.3 streamlines this process with fewer round trips and removes weak cipher suites, improving both security and performance."},
        {"question": "What IPsec mode encrypts only the payload, leaving original IP headers intact?", "answer": "Transport mode", "alternatives": ["IPsec transport mode"], "explanation": "IPsec transport mode encrypts only the IP payload, keeping original IP headers visible. This is efficient for end-to-end communication between two hosts but exposes routing information. Tunnel mode encrypts the entire original packet and adds new headers, hiding source/destination. Transport mode is common for host-to-host VPNs."},
        {"question": "What protocol prevents replay attacks by using sequence numbers and time windows?", "answer": "Kerberos", "alternatives": ["Kerberos authentication"], "explanation": "Kerberos uses timestamps and ticket lifetimes to prevent replay attacks. Tickets are time-limited, and systems must have synchronized clocks. The authentication process involves the KDC (Key Distribution Center) issuing time-stamped tickets that expire. This prevents attackers from capturing and replaying valid authentication messages to gain unauthorized access."},
        {"question": "What VPN protocol offers the best balance of security and performance?", "answer": "OpenVPN", "alternatives": ["OpenVPN protocol"], "explanation": "OpenVPN is an open-source VPN protocol using SSL/TLS for encryption and key exchange. It supports various authentication methods, works through firewalls, and provides strong security with good performance. It runs in userspace rather than kernel space, making it portable across platforms. WireGuard is a newer alternative with simpler code and potentially better performance."},
        {"question": "What extension to SSH provides secure graphical remote desktop capabilities?", "answer": "X11 forwarding", "alternatives": ["SSH X forwarding"], "explanation": "SSH X11 forwarding tunnels X Window System connections through SSH, allowing secure remote graphical applications. Applications run on the remote server but display on the local machine. While secure, it can be slow over high-latency connections. Alternatives like VNC over SSH or RDP tunneling provide full desktop access."},
        {"question": "What certificate authority mechanism allows verification of certificate validity status?", "answer": "OCSP", "alternatives": ["Online Certificate Status Protocol"], "explanation": "OCSP (Online Certificate Status Protocol) provides real-time certificate revocation checking, allowing clients to verify whether certificates are still valid. It's more efficient than downloading entire Certificate Revocation Lists (CRLs). OCSP stapling improves performance and privacy by having servers query OCSP and include signed responses in TLS handshakes."},
        {"question": "What wireless security protocol introduced 192-bit encryption for enterprise networks?", "answer": "WPA3-Enterprise", "alternatives": ["WPA3 Enterprise mode"], "explanation": "WPA3-Enterprise offers 192-bit security with GCMP-256 encryption, HMAC-SHA-384 for key derivation, and ECDSA-384 for authentication. This provides government-grade security for enterprise networks with high security requirements. It maintains backward compatibility with WPA2 while significantly strengthening cryptographic security for sensitive environments."},
        {"question": "What protocol secures voice and video communications over IP networks?", "answer": "SRTP", "alternatives": ["Secure Real-time Transport Protocol"], "explanation": "SRTP (Secure Real-time Transport Protocol) extends RTP with encryption, message authentication, and replay protection for VoIP and video calls. It uses AES encryption for confidentiality and HMAC-SHA1 for authentication. SRTP is used in applications like WebRTC, Zoom, and enterprise telephony systems. Key exchange is typically handled by protocols like DTLS-SRTP."},
        {"question": "What protocol establishes authenticated, encrypted channels without requiring infrastructure?", "answer": "TLS-PSK", "alternatives": ["Pre-Shared Key TLS", "PSK"], "explanation": "TLS-PSK (Pre-Shared Key) mode allows TLS connections using pre-shared symmetric keys instead of certificates. This is useful for resource-constrained IoT devices or closed systems where distributing certificates is impractical. PSK eliminates certificate overhead but requires secure key distribution and management. It's common in industrial control and IoT applications."},
        {"question": "What mechanism allows websites to specify which other domains can embed their content?", "answer": "CORS", "alternatives": ["Cross-Origin Resource Sharing"], "explanation": "CORS (Cross-Origin Resource Sharing) is a security mechanism that allows servers to specify which origins can access their resources. Browsers enforce the same-origin policy, blocking cross-origin requests by default. CORS headers like Access-Control-Allow-Origin relax this restriction when appropriate, enabling secure cross-domain API access while preventing unauthorized data theft."}
    ],
    "difficult": [
        {"question": "What perfect forward secrecy mechanism ensures session keys aren't compromised if private keys are stolen?", "answer": "Ephemeral Diffie-Hellman", "alternatives": ["DHE", "ECDHE", "Ephemeral key exchange"], "explanation": "Ephemeral Diffie-Hellman (DHE/ECDHE) generates temporary session keys that aren't derived from long-term private keys. Even if an attacker later obtains the server's private key, they can't decrypt previous sessions. This provides perfect forward secrecy. TLS 1.3 requires ephemeral key exchange. ECDHE (Elliptic Curve) is more efficient than traditional DHE."},
        {"question": "What protocol framework enables mutual authentication without passwords using public key cryptography?", "answer": "FIDO2", "alternatives": ["WebAuthn", "Fast Identity Online"], "explanation": "FIDO2 enables passwordless authentication using public key cryptography and local authentication (biometrics, PINs, security keys). Each site receives unique credentials, preventing credential reuse and phishing. The private key never leaves the device. FIDO2 comprises WebAuthn (web standard) and CTAP (communication with authenticators). Major browsers and platforms support it."},
        {"question": "What TLS extension allows clients to send the target hostname during handshake?", "answer": "SNI", "alternatives": ["Server Name Indication"], "explanation": "SNI (Server Name Indication) allows multiple HTTPS sites to share a single IP address by sending the hostname in the TLS handshake before encryption begins. This enables servers to present the correct certificate. While essential for virtual hosting, SNI exposes the target hostname to network observers. Encrypted SNI (ESNI) in TLS 1.3 addresses this privacy concern."},
        {"question": "What quantum-resistant key exchange algorithm is being standardized by NIST?", "answer": "Kyber", "alternatives": ["CRYSTALS-Kyber", "ML-KEM"], "explanation": "Kyber (CRYSTALS-Kyber) is a lattice-based key exchange algorithm selected by NIST for post-quantum cryptography standardization. It resists attacks by quantum computers that would break current RSA and ECC-based systems. Kyber offers good performance and security levels. Organizations are beginning to implement post-quantum crypto in preparation for quantum computer threats."},
        {"question": "What mechanism allows servers to push certificate status information to clients during TLS handshakes?", "answer": "OCSP stapling", "alternatives": ["TLS certificate status request"], "explanation": "OCSP stapling allows servers to obtain signed, time-stamped OCSP responses and send them during TLS handshakes. This improves performance (clients don't query OCSP responders), privacy (clients don't reveal which sites they're visiting), and reliability (handshake doesn't depend on OCSP responder availability). It's now a TLS best practice."},
        {"question": "What protocol extension encrypts initial client data in TLS 1.3 to prevent passive surveillance?", "answer": "0-RTT", "alternatives": ["Zero Round Trip Time", "Early data"], "explanation": "TLS 1.3 0-RTT mode allows clients to send encrypted application data in the first flight of the handshake, eliminating the latency penalty of TLS for resumed sessions. However, 0-RTT data isn't protected against replay attacks, so it should only be used for idempotent operations. This significantly improves performance for frequent connections."},
        {"question": "What cryptographic protocol allows proving password knowledge without revealing it to the server?", "answer": "SRP", "alternatives": ["Secure Remote Password", "Zero-knowledge password proof"], "explanation": "SRP (Secure Remote Password) is a zero-knowledge password authentication protocol where clients prove they know the password without sending it or any information that could determine it. Even the server doesn't store the password, only a verifier. This protects against server compromise and network eavesdropping. SRP is used in some VPN and encrypted backup systems."},
        {"question": "What protocol provides authenticated encryption for wireless networks using GCMP?", "answer": "WPA3", "alternatives": ["WiFi Protected Access 3"], "explanation": "WPA3 uses GCMP (Galois/Counter Mode Protocol) providing authenticated encryption with stronger cryptography than WPA2's CCMP. It also implements SAE (Simultaneous Authentication of Equals) replacing WPA2's PSK, protecting against offline dictionary attacks. WPA3 provides forward secrecy and mandatory Protected Management Frames (PMF), significantly improving WiFi security."},
        {"question": "What mechanism prevents TLS downgrade attacks by having servers declare minimum supported versions?", "answer": "TLS version negotiation", "alternatives": ["TLS fallback protection", "SCSV"], "explanation": "TLS version negotiation allows clients and servers to agree on the highest mutually supported version. TLS_FALLBACK_SCSV (Signaling Cipher Suite Value) prevents downgrade attacks where attackers force use of older, vulnerable versions. TLS 1.3 improves this with encrypted version negotiation. Servers should disable obsolete versions (SSL 3.0, TLS 1.0/1.1) entirely."},
        {"question": "What protocol provides confidential, authenticated channels for DNS queries?", "answer": "DNS over HTTPS", "alternatives": ["DoH", "DNS-over-HTTPS"], "explanation": "DNS over HTTPS (DoH) encrypts DNS queries within HTTPS connections, providing privacy and preventing DNS surveillance and manipulation. Unlike DNS over TLS (DoT) which uses a dedicated port, DoH uses standard HTTPS port 443, making it harder to block. Major browsers support DoH. However, it's controversial as it bypasses network-level DNS filtering and monitoring."}
    ]
}

ALL_ADDITIONAL_QUESTIONS['security_protocols'] = SECURITY_PROTOCOLS_QUESTIONS

# 10. Cyber Defense
CYBER_DEFENSE_QUESTIONS = {
    "easy": [
        {"question": "What security system monitors network traffic and blocks suspicious activity?", "answer": "Firewall", "alternatives": ["Network firewall"], "explanation": "Firewalls are the first line of defense in network security, controlling incoming and outgoing traffic based on security rules. They can be hardware devices or software applications. Modern firewalls include stateful inspection, deep packet inspection, and application-aware filtering. Firewalls block unauthorized access while allowing legitimate communication."},
        {"question": "What software detects and removes malicious programs from computers?", "answer": "Antivirus", "alternatives": ["Antivirus software", "Anti-malware"], "explanation": "Antivirus software scans files and programs for known malware signatures, suspicious behaviors, or heuristic patterns indicating malicious intent. Modern solutions include real-time protection, automatic updates, and cloud-based threat intelligence. While essential, antivirus should be part of a layered defense strategy since new malware appears constantly."},
        {"question": "What practice involves creating copies of data to prevent loss from failures or attacks?", "answer": "Backup", "alternatives": ["Data backup"], "explanation": "Regular backups are critical for recovering from ransomware, hardware failures, or disasters. The 3-2-1 rule recommends three copies on two different media types with one offsite. Backups should be tested regularly and protected from tampering. Automated backup solutions and immutable storage help ensure recovery capability."},
        {"question": "What security measure requires users to prove their identity before accessing resources?", "answer": "Authentication", "alternatives": ["User authentication"], "explanation": "Authentication verifies user identity through credentials like passwords, biometrics, or security tokens. It's the first step in access control. Strong authentication uses multiple factors (something you know, have, or are) to increase security. Authentication prevents unauthorized access but must be followed by proper authorization to control what users can do."},
        {"question": "What security concept limits user permissions to only what's necessary for their job?", "answer": "Least privilege", "alternatives": ["Principle of least privilege"], "explanation": "The principle of least privilege grants users, processes, and systems only the minimum permissions needed to perform their functions. This limits damage from compromised accounts, reduces attack surface, and helps contain breaches. Regular permission reviews and just-in-time access help maintain least privilege."},
        {"question": "What process involves applying updates to fix security vulnerabilities in software?", "answer": "Patching", "alternatives": ["Security patching", "Software updates"], "explanation": "Patching closes security vulnerabilities by updating software with fixes from vendors. Unpatched systems are common attack vectors. Effective patch management includes testing patches, prioritizing critical updates, and maintaining inventory of all systems. Automated patch management helps ensure timely updates across large environments."},
        {"question": "What training helps employees recognize and resist social engineering attacks?", "answer": "Security awareness training", "alternatives": ["Cybersecurity training"], "explanation": "Security awareness training educates employees about threats like phishing, social engineering, and safe computing practices. Humans are often the weakest link in security. Regular training, simulated phishing exercises, and clear policies help create a security-conscious culture. Training should cover recognizing threats, reporting incidents, and following security procedures."},
        {"question": "What security approach uses multiple defensive layers to protect systems?", "answer": "Defense in depth", "alternatives": ["Layered security"], "explanation": "Defense in depth implements multiple security layers so if one fails, others provide protection. Layers include network security, host security, application security, and data security. This approach assumes breaches will occur and aims to detect, contain, and minimize damage. No single security measure is sufficient against determined attackers."},
        {"question": "What document outlines how an organization responds to security incidents?", "answer": "Incident response plan", "alternatives": ["IR plan", "Security incident response plan"], "explanation": "An incident response plan defines procedures for detecting, responding to, recovering from, and learning from security incidents. It specifies roles, communication protocols, containment strategies, and recovery steps. Regular testing through tabletop exercises ensures the plan works when needed. Good IR plans minimize damage and recovery time."},
        {"question": "What type of security testing simulates real attacks to find vulnerabilities?", "answer": "Penetration testing", "alternatives": ["Pen testing", "Ethical hacking"], "explanation": "Penetration testing involves authorized simulated attacks to identify vulnerabilities before malicious actors find them. Pen testers use the same tools and techniques as attackers but with permission and defined scope. Results help organizations prioritize security improvements. Regular pen testing is essential for maintaining strong security posture."}
    ],
    "average": [
        {"question": "What system detects potential security threats by analyzing network traffic patterns?", "answer": "Intrusion Detection System", "alternatives": ["IDS"], "explanation": "IDS monitors network traffic for suspicious activity and known attack signatures, alerting administrators to potential threats. Unlike firewalls that block traffic, IDS passively observes and alerts. NIDS monitors network segments; HIDS monitors hosts. IDS can use signature-based detection (known attacks) or anomaly-based detection (unusual behavior). False positives require careful tuning."},
        {"question": "What security system actively blocks detected threats in addition to alerting?", "answer": "Intrusion Prevention System", "alternatives": ["IPS"], "explanation": "IPS combines IDS detection capabilities with active blocking. When threats are detected, IPS can drop malicious packets, block IP addresses, or reset connections. IPS sits inline with traffic flow, unlike passive IDS. While more effective than IDS, IPS risks blocking legitimate traffic if misconfigured. Modern NGFW (Next-Generation Firewalls) integrate IPS functionality."},
        {"question": "What authentication method verifies identity using physical or behavioral characteristics?", "answer": "Biometric authentication", "alternatives": ["Biometrics"], "explanation": "Biometric authentication uses unique physical (fingerprints, iris, facial recognition) or behavioral (typing rhythm, gait) characteristics. Biometrics are difficult to forge or steal and don't require remembering passwords. However, they can't be changed if compromised and raise privacy concerns. Multi-factor systems often combine biometrics with other authentication methods."},
        {"question": "What security architecture isolates network segments to contain breaches?", "answer": "Network segmentation", "alternatives": ["Network isolation"], "explanation": "Network segmentation divides networks into isolated segments with controlled connections between them. This limits lateral movement if attackers breach one segment. VLANs, subnets, and firewalls implement segmentation. Critical systems should be in separate segments with strict access controls. Micro-segmentation extends this concept to individual workloads."},
        {"question": "What security zone contains decoy systems to detect and analyze attacks?", "answer": "Honeypot", "alternatives": ["Honeynet"], "explanation": "Honeypots are decoy systems that appear vulnerable to attract attackers. They have no legitimate use, so any interaction indicates malicious activity. Honeypots provide early warning, gather attack intelligence, and distract attackers from real systems. Honeynets are networks of honeypots. However, they require careful isolation to prevent attackers from pivoting to production systems."},
        {"question": "What centralized platform collects and analyzes security logs from multiple sources?", "answer": "SIEM", "alternatives": ["Security Information and Event Management"], "explanation": "SIEM systems aggregate logs from firewalls, servers, applications, and security tools, correlating events to detect threats. They provide real-time analysis, alerting, forensics, and compliance reporting. Modern SIEMs use machine learning to detect anomalies. However, SIEMs require significant tuning and skilled analysts to be effective. They're central to Security Operations Centers (SOCs)."},
        {"question": "What proactive security approach assumes breach and focuses on threat detection?", "answer": "Threat hunting", "alternatives": ["Proactive threat hunting"], "explanation": "Threat hunting proactively searches for threats that evaded automated defenses. Unlike reactive incident response, hunters use intelligence, behavioral analysis, and hypothesis testing to find hidden adversaries. This assumes breaches occur and focuses on early detection before major damage. Effective hunting requires skilled analysts, good tools, and comprehensive visibility."},
        {"question": "What security technique analyzes malware behavior in a controlled environment?", "answer": "Sandboxing", "alternatives": ["Sandbox analysis"], "explanation": "Sandboxing executes suspicious files in isolated virtual environments to observe behavior without risking production systems. This detects malware that evades signature-based detection. Sandboxes monitor file operations, network connections, registry changes, and system calls. Advanced malware may detect sandboxes and alter behavior, requiring evasion-resistant sandboxing techniques."},
        {"question": "What security framework verifies every access request regardless of network location?", "answer": "Zero Trust", "alternatives": ["Zero Trust Architecture", "Zero Trust Security"], "explanation": "Zero Trust assumes no implicit trust based on network location - every access request is fully authenticated, authorized, and encrypted regardless of origin. It eliminates the perimeter-based security model. Key principles include verify explicitly, use least privilege, and assume breach. Implementation requires strong identity management, micro-segmentation, and continuous monitoring."},
        {"question": "What team simulates adversary tactics to test an organization's security defenses?", "answer": "Red team", "alternatives": ["Red teaming"], "explanation": "Red teams simulate real-world attackers using advanced techniques to test security controls and incident response. Unlike pen testing with defined scope, red teaming is adversarial with minimal constraints. The goal is identifying gaps in people, processes, and technology. Blue teams defend; purple teams facilitate cooperation. Red teaming provides realistic assessment of security posture."}
    ],
    "difficult": [
        {"question": "What advanced malware analysis technique reverses compiled code to understand its functionality?", "answer": "Reverse engineering", "alternatives": ["Code reverse engineering", "Malware reverse engineering"], "explanation": "Reverse engineering examines malware binaries using disassemblers (IDA Pro, Ghidra) and debuggers to understand functionality, identify indicators of compromise, and develop signatures. This requires deep understanding of assembly language, file formats, and operating system internals. Static analysis examines code without execution; dynamic analysis observes runtime behavior."},
        {"question": "What threat intelligence approach attributes attacks to specific adversary groups?", "answer": "Threat attribution", "alternatives": ["Adversary attribution"], "explanation": "Threat attribution identifies which threat actor or nation-state is behind attacks by analyzing tactics, techniques, procedures (TTPs), infrastructure, and code similarities. This is challenging as attackers use false flags and share tools. Attribution informs defensive priorities and geopolitical responses. Frameworks like MITRE ATT&CK help categorize adversary behaviors."},
        {"question": "What security orchestration platform automates incident response workflows?", "answer": "SOAR", "alternatives": ["Security Orchestration, Automation and Response"], "explanation": "SOAR platforms automate repetitive security tasks and orchestrate complex workflows across multiple tools. They integrate with SIEM, firewalls, EDR, and threat intelligence to enable automated containment, investigation, and response. SOAR reduces response time, ensures consistent processes, and allows analysts to focus on complex threats. Playbooks define automated response procedures."},
        {"question": "What technique analyzes system memory to detect rootkits and advanced malware?", "answer": "Memory forensics", "alternatives": ["RAM analysis", "Volatile memory analysis"], "explanation": "Memory forensics examines system RAM to find malware, encryption keys, passwords, and attack evidence that doesn't persist on disk. Fileless malware and rootkits often hide only in memory. Tools like Volatility analyze memory dumps to recover processes, network connections, and injected code. Memory forensics is crucial for investigating advanced persistent threats."},
        {"question": "What advanced firewall capability inspects encrypted traffic for threats?", "answer": "SSL/TLS inspection", "alternatives": ["HTTPS inspection", "Deep packet inspection"], "explanation": "SSL/TLS inspection decrypts encrypted traffic, inspects content for threats, then re-encrypts it. This is necessary as most traffic is now encrypted, providing a hiding place for malware. Implementation requires careful certificate management to avoid breaking trust. Privacy concerns and performance impact require balanced policies about what traffic to inspect."},
        {"question": "What security approach detects threats by identifying deviations from baseline behavior?", "answer": "Behavioral analysis", "alternatives": ["Anomaly detection", "User and Entity Behavior Analytics", "UEBA"], "explanation": "Behavioral analysis establishes baselines of normal behavior for users, systems, and networks, then detects anomalies indicating potential threats. UEBA (User and Entity Behavior Analytics) uses machine learning to identify compromised accounts, insider threats, and advanced attacks that evade signature-based detection. This catches novel attacks but requires tuning to reduce false positives."},
        {"question": "What isolation technique runs applications in separate containers to limit malware impact?", "answer": "Application sandboxing", "alternatives": ["Containerization", "Process isolation"], "explanation": "Application sandboxing restricts what applications can access using OS-level isolation. Each app runs in a restricted environment with limited file system, network, and system call access. This contains malware even if an application is compromised. Technologies include Docker containers, browser sandboxes, and mobile app sandboxes. However, sandbox escapes remain a concern."},
        {"question": "What deception technology creates fake network assets to detect lateral movement?", "answer": "Deception technology", "alternatives": ["Active defense", "Cyber deception"], "explanation": "Deception technology deploys fake credentials, servers, databases, and files throughout networks. Any access to these decoys indicates reconnaissance or lateral movement. Unlike passive honeypots, deception tools integrate with production networks. They provide high-fidelity alerts since legitimate users shouldn't access decoys. This shifts defenders' advantage by creating a minefield for attackers."},
        {"question": "What technique isolates potentially compromised systems while investigating incidents?", "answer": "Network containment", "alternatives": ["Quarantine", "Incident containment"], "explanation": "Network containment isolates suspected compromised systems from the network without shutting them down, allowing investigation while preventing malware spread. Techniques include VLAN changes, firewall rules, or EDR-enforced isolation. Containment balances business continuity with security - systems remain operational but can't communicate maliciously. This is crucial for ransomware and APT incidents."},
        {"question": "What advanced persistent threat defense mechanism detects command and control communications?", "answer": "Network traffic analysis", "alternatives": ["NTA", "Flow analysis"], "explanation": "Network Traffic Analysis (NTA) monitors network flows to detect C2 (command and control) communications, data exfiltration, and lateral movement. Unlike signature-based detection, NTA uses machine learning and behavioral analysis to identify suspicious patterns like beaconing, unusual protocols, or abnormal data volumes. This is effective against APTs that evade endpoint detection."}
    ]
}

ALL_ADDITIONAL_QUESTIONS['cyber_defense'] = CYBER_DEFENSE_QUESTIONS
