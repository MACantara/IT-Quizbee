{
  "subtopic_id": "design_patterns",
  "subtopic_name": "Design Patterns",
  "mode": "finals",
  "difficulty": "average",
  "questions": [
    {
      "question": "What is the Prototype pattern?",
      "answer": "Create objects by cloning existing",
      "alternatives": [
        "Cloning"
      ],
      "explanation": "Prototype: clone existing. Purpose: avoid expensive creation. Benefit: performance. Example: graphics objects. Importance: creational pattern."
    },
    {
      "question": "What is the State pattern?",
      "answer": "Change behavior based on state",
      "alternatives": [
        "State behavior"
      ],
      "explanation": "State: state objects. Purpose: simplify conditionals. Benefit: clear structure. Example: traffic light. Importance: behavioral pattern."
    },
    {
      "question": "What is the Template Method pattern?",
      "answer": "Define algorithm skeleton, subclass fills details",
      "alternatives": [
        "Algorithm skeleton"
      ],
      "explanation": "Template: steps defined. Hooks: subclass implements. Purpose: reuse structure. Benefit: consistent. Example: frameworks. Importance: behavioral pattern."
    },
    {
      "question": "What is the Chain of Responsibility pattern?",
      "answer": "Pass request along chain",
      "alternatives": [
        "Request chain"
      ],
      "explanation": "Chain: linked handlers. Purpose: decouple. Benefit: flexible handling. Example: logging. Importance: behavioral pattern."
    },
    {
      "question": "What is the Facade pattern?",
      "answer": "Provide unified interface to subsystem",
      "alternatives": [
        "Simple interface"
      ],
      "explanation": "Facade: simplifies. Purpose: reduce complexity. Benefit: easier usage. Example: frameworks. Importance: structural pattern."
    },
    {
      "question": "What is the Proxy pattern?",
      "answer": "Control access via surrogate",
      "alternatives": [
        "Surrogate"
      ],
      "explanation": "Proxy: placeholder. Purpose: lazy loading, logging. Benefit: control. Example: remote proxy. Importance: structural pattern."
    },
    {
      "question": "What is the Bridge pattern?",
      "answer": "Decouple abstraction from implementation",
      "alternatives": [
        "Decoupling"
      ],
      "explanation": "Bridge: separate hierarchies. Purpose: flexibility. Benefit: change independently. Example: cross-platform UI. Importance: structural pattern."
    },
    {
      "question": "What is the Composite pattern?",
      "answer": "Treat individual and composite uniformly",
      "alternatives": [
        "Tree structure"
      ],
      "explanation": "Composite: tree nodes. Purpose: uniform interface. Benefit: recursive operations. Example: file system. Importance: structural pattern."
    },
    {
      "question": "What is the Interpreter pattern?",
      "answer": "Define grammar as object structure",
      "alternatives": [
        "Grammar"
      ],
      "explanation": "Interpreter: parse language. Purpose: DSL creation. Benefit: flexibility. Example: SQL parsers. Importance: behavioral pattern."
    },
    {
      "question": "What is the Mediator pattern?",
      "answer": "Centralize complex communication",
      "alternatives": [
        "Communication hub"
      ],
      "explanation": "Mediator: central coordinator. Purpose: decouple. Benefit: reduce complexity. Example: dialog boxes. Importance: behavioral pattern."
    }
  ]
}