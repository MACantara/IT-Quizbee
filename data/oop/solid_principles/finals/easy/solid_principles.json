{
  "subtopic_id": "solid_principles",
  "subtopic_name": "SOLID Principles",
  "mode": "finals",
  "difficulty": "easy",
  "questions": [
    {
      "question": "What does S in SOLID mean?",
      "answer": "Single Responsibility",
      "alternatives": ["Single Responsibility Principle", "SRP"],
      "explanation": "Single Responsibility means one reason to change."
    },
    {
      "question": "What does O in SOLID mean?",
      "answer": "Open/Closed",
      "alternatives": ["Open/Closed Principle", "OCP"],
      "explanation": "Open/Closed means open for extension, closed for modification."
    },
    {
      "question": "What does L in SOLID mean?",
      "answer": "Liskov Substitution",
      "alternatives": ["Liskov Substitution Principle", "LSP"],
      "explanation": "Liskov Substitution ensures subtype compatibility."
    },
    {
      "question": "What does I in SOLID mean?",
      "answer": "Interface Segregation",
      "alternatives": ["Interface Segregation Principle", "ISP"],
      "explanation": "Interface Segregation prevents large interfaces."
    },
    {
      "question": "What does D in SOLID mean?",
      "answer": "Dependency Inversion",
      "alternatives": ["Dependency Inversion Principle", "DIP"],
      "explanation": "Dependency Inversion depends on abstractions."
    },
    {
      "question": "What principle limits class responsibilities?",
      "answer": "Single Responsibility",
      "alternatives": ["SRP"],
      "explanation": "Classes should have one reason to change."
    },
    {
      "question": "What principle enables extension without modification?",
      "answer": "Open/Closed",
      "alternatives": ["OCP"],
      "explanation": "Extend behavior through inheritance and composition."
    },
    {
      "question": "What principle ensures subtype compatibility?",
      "answer": "Liskov Substitution",
      "alternatives": ["LSP"],
      "explanation": "Subtypes must replace base types correctly."
    },
    {
      "question": "What principle prefers small interfaces?",
      "answer": "Interface Segregation",
      "alternatives": ["ISP"],
      "explanation": "Clients should not depend on unused methods."
    },
    {
      "question": "What principle depends on abstractions?",
      "answer": "Dependency Inversion",
      "alternatives": ["DIP"],
      "explanation": "High-level modules should not depend on low-level modules."
    }
  ]
}