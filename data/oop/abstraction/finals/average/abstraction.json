{
  "subtopic_id": "abstraction",
  "subtopic_name": "Abstraction",
  "mode": "finals",
  "difficulty": "average",
  "questions": [
    {
      "question": "What is the difference between interface and abstract class?",
      "answer": "Interface has no implementation, abstract may have",
      "alternatives": [
        "Distinctions"
      ],
      "explanation": "Interface: pure contract. Abstract: partial implementation. Fields: abstract can have, interface cannot (mostly). Method: abstract optional, interface required. Multiple: interface yes, abstract no. Language specific: Java vs others. Importance: distinction."
    },
    {
      "question": "What are levels of abstraction?",
      "answer": "Hierarchical layers of detail",
      "alternatives": [
        "Abstraction levels"
      ],
      "explanation": "Levels: high-level abstractions use lower-level. Example: application -> OS -> hardware. Purpose: manage complexity. Benefit: understand at each layer. Importance: system design."
    },
    {
      "question": "What is a data type abstraction?",
      "answer": "Hide internal structure of data types",
      "alternatives": [
        "Type abstraction"
      ],
      "explanation": "Abstraction: int operations hidden. Implementation: compiler detail. User: uses int without knowing. Benefit: simplicity. Example: List, Stack. Importance: data structure."
    },
    {
      "question": "What is semantic abstraction?",
      "answer": "Meaningful operations on data",
      "alternatives": [
        "Operational abstraction"
      ],
      "explanation": "Abstraction: meaningful operations. Example: push/pop for Stack. Purpose: clear semantics. Benefit: intuitive usage. Importance: API design."
    },
    {
      "question": "What is procedural abstraction?",
      "answer": "Hiding procedure implementation",
      "alternatives": [
        "Function abstraction"
      ],
      "explanation": "Abstraction: function hides algorithm. Details: caller doesn't care. Purpose: reuse code. Benefit: avoid reimplementation. Example: library functions. Importance: code reuse."
    },
    {
      "question": "What is control abstraction?",
      "answer": "Hide control flow implementation",
      "alternatives": [
        "Control hiding"
      ],
      "explanation": "Abstraction: how loop works hidden. User: uses for/while without knowing. Benefit: simplicity. Language: provides keywords. Importance: language feature."
    },
    {
      "question": "What is the principle of least privilege?",
      "answer": "Grant minimum necessary access",
      "alternatives": [
        "Minimal access"
      ],
      "explanation": "Principle: restrict access. Purpose: security, prevent misuse. Implementation: private by default. Benefit: safer code. Importance: security practice."
    },
    {
      "question": "What is a getter method?",
      "answer": "Read-only access to private member",
      "alternatives": [
        "Accessor"
      ],
      "explanation": "Getter: retrieves value. Naming: get prefix. Purpose: controlled read access. Benefit: enforce immutability. Example: getName(). Importance: encapsulation."
    },
    {
      "question": "What is a setter method?",
      "answer": "Write access with validation",
      "alternatives": [
        "Mutator"
      ],
      "explanation": "Setter: modifies value. Naming: set prefix. Purpose: controlled write access. Validation: can validate before set. Example: setAge(int). Importance: encapsulation."
    },
    {
      "question": "What is defensive copying?",
      "answer": "Copy when returning mutable objects",
      "alternatives": [
        "Copy defense"
      ],
      "explanation": "Copying: prevent external modification. Purpose: protect internal state. Example: return new ArrayList(list). Benefit: thread safety. Importance: immutability."
    }
  ]
}