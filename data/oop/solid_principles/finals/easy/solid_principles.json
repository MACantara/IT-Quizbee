{
  "subtopic_id": "solid_principles",
  "subtopic_name": "SOLID Principles",
  "mode": "finals",
  "difficulty": "easy",
  "questions": [
    {
      "question": "What does SOLID stand for?",
      "answer": "Single, Open, Liskov, Interface, Dependency",
      "alternatives": [
        "SOLID"
      ],
      "explanation": "SOLID: design principles. Purpose: maintainable code. Principles: 5 key concepts. Benefit: quality. Importance: industry standard."
    },
    {
      "question": "What is the Single Responsibility Principle?",
      "answer": "Class should have one reason to change",
      "alternatives": [
        "SRP"
      ],
      "explanation": "SRP: one job. Purpose: maintainability. Benefit: focused. Example: User class - auth only. Importance: first principle."
    },
    {
      "question": "What is the Open/Closed Principle?",
      "answer": "Open for extension, closed for modification",
      "alternatives": [
        "OCP"
      ],
      "explanation": "OCP: extend, don't modify. Purpose: stability. Benefit: new features without breakage. Example: strategy pattern. Importance: second principle."
    },
    {
      "question": "What is the Liskov Substitution Principle?",
      "answer": "Subclass usable wherever parent is used",
      "alternatives": [
        "LSP"
      ],
      "explanation": "LSP: substitution safe. Purpose: correctness. Benefit: predictable behavior. Example: Square vs Rectangle. Importance: third principle."
    },
    {
      "question": "What is the Interface Segregation Principle?",
      "answer": "Many client-specific interfaces instead of one large",
      "alternatives": [
        "ISP"
      ],
      "explanation": "ISP: specific interfaces. Purpose: flexibility. Benefit: loose coupling. Example: multiple small interfaces. Importance: fourth principle."
    },
    {
      "question": "What is the Dependency Inversion Principle?",
      "answer": "Depend on abstractions, not concretions",
      "alternatives": [
        "DIP"
      ],
      "explanation": "DIP: abstraction dependency. Purpose: flexibility. Benefit: swap implementations. Example: dependency injection. Importance: fifth principle."
    },
    {
      "question": "Why is SOLID important?",
      "answer": "Makes code maintainable, scalable, testable",
      "alternatives": [
        "Benefits"
      ],
      "explanation": "SOLID: quality code. Benefits: easy changes, testing, understanding. Industry: expected knowledge. Importance: best practice."
    },
    {
      "question": "What is violation of SRP?",
      "answer": "Class with multiple responsibilities",
      "alternatives": [
        "SRP violation"
      ],
      "explanation": "Violation: God object. Problem: hard to change. Solution: split. Example: User managing auth and database. Importance: understanding."
    },
    {
      "question": "What is violation of OCP?",
      "answer": "Modifying code instead of extending",
      "alternatives": [
        "OCP violation"
      ],
      "explanation": "Violation: changing existing code. Problem: risk of bugs. Solution: abstract, extend. Example: adding if for new type. Importance: understanding."
    },
    {
      "question": "What is violation of LSP?",
      "answer": "Subclass breaks parent contract",
      "alternatives": [
        "LSP violation"
      ],
      "explanation": "Violation: incompatible override. Problem: unexpected behavior. Solution: maintain contract. Example: Square reduces width/height. Importance: understanding."
    }
  ]
}