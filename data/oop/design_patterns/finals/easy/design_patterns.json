{
  "subtopic_id": "design_patterns",
  "subtopic_name": "Design Patterns",
  "mode": "finals",
  "difficulty": "easy",
  "questions": [
    {
      "question": "What is a design pattern?",
      "answer": "Reusable solution to common problem",
      "alternatives": [
        "Pattern"
      ],
      "explanation": "Pattern: proven approach. Purpose: solve recurring problems. Benefit: faster development, consistency. Example: Singleton. Importance: best practice."
    },
    {
      "question": "What are the three categories of design patterns?",
      "answer": "Creational, Structural, Behavioral",
      "alternatives": [
        "Pattern types"
      ],
      "explanation": "Categories: Creational (object creation), Structural (composition), Behavioral (interaction). Count: 23 GOF patterns. Purpose: organize solutions. Importance: classification."
    },
    {
      "question": "What is the Singleton pattern?",
      "answer": "Single instance throughout application",
      "alternatives": [
        "One instance"
      ],
      "explanation": "Singleton: only one. Purpose: shared resource. Implementation: private constructor. Example: Logger. Importance: creational pattern."
    },
    {
      "question": "What is the Factory pattern?",
      "answer": "Create objects without specifying classes",
      "alternatives": [
        "Object creation"
      ],
      "explanation": "Factory: creates objects. Purpose: encapsulate creation. Benefit: easy to add types. Example: FrameworkFactory. Importance: creational pattern."
    },
    {
      "question": "What is the Builder pattern?",
      "answer": "Construct complex objects step by step",
      "alternatives": [
        "Step by step"
      ],
      "explanation": "Builder: fluent construction. Purpose: readability. Benefit: optional parameters. Example: StringBuilder. Importance: creational pattern."
    },
    {
      "question": "What is the Adapter pattern?",
      "answer": "Convert interface to another interface",
      "alternatives": [
        "Interface conversion"
      ],
      "explanation": "Adapter: bridges incompatible. Purpose: compatibility. Benefit: reuse without modification. Example: legacy integration. Importance: structural pattern."
    },
    {
      "question": "What is the Decorator pattern?",
      "answer": "Add behavior to object dynamically",
      "alternatives": [
        "Add behavior"
      ],
      "explanation": "Decorator: wraps object. Purpose: extend functionality. Benefit: flexible. Alternative: inheritance. Example: FileInputStream. Importance: structural pattern."
    },
    {
      "question": "What is the Observer pattern?",
      "answer": "Notify multiple objects of state change",
      "alternatives": [
        "Publish-subscribe"
      ],
      "explanation": "Observer: registered listeners. Purpose: loose coupling. Benefit: scalable notifications. Example: UI events. Importance: behavioral pattern."
    },
    {
      "question": "What is the Strategy pattern?",
      "answer": "Encapsulate interchangeable algorithms",
      "alternatives": [
        "Algorithms"
      ],
      "explanation": "Strategy: swappable algorithms. Purpose: runtime selection. Benefit: extensible. Example: sorting algorithms. Importance: behavioral pattern."
    },
    {
      "question": "What is the Command pattern?",
      "answer": "Encapsulate request as object",
      "alternatives": [
        "Request object"
      ],
      "explanation": "Command: object request. Purpose: queue, undo, redo. Benefit: decoupling. Example: macro, undo. Importance: behavioral pattern."
    }
  ]
}