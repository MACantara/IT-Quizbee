{
  "subtopic_id": "solid_principles",
  "subtopic_name": "SOLID Principles",
  "mode": "finals",
  "difficulty": "easy",
  "questions": [
    {
      "question": "What does S in SOLID mean?",
      "answer": "Single Responsibility",
      "alternatives": [
        "Single Responsibility Principle",
        "SRP"
      ],
      "explanation": "Single Responsibility means one reason to change.",
      "id": "sol_pri_sol_pri_e_finals_000"
    },
    {
      "question": "What does O in SOLID mean?",
      "answer": "Open/Closed",
      "alternatives": [
        "Open/Closed Principle",
        "OCP"
      ],
      "explanation": "Open/Closed means open for extension, closed for modification.",
      "id": "sol_pri_sol_pri_e_finals_001"
    },
    {
      "question": "What does L in SOLID mean?",
      "answer": "Liskov Substitution",
      "alternatives": [
        "Liskov Substitution Principle",
        "LSP"
      ],
      "explanation": "Liskov Substitution ensures subtype compatibility.",
      "id": "sol_pri_sol_pri_e_finals_002"
    },
    {
      "question": "What does I in SOLID mean?",
      "answer": "Interface Segregation",
      "alternatives": [
        "Interface Segregation Principle",
        "ISP"
      ],
      "explanation": "Interface Segregation prevents large interfaces.",
      "id": "sol_pri_sol_pri_e_finals_003"
    },
    {
      "question": "What does D in SOLID mean?",
      "answer": "Dependency Inversion",
      "alternatives": [
        "Dependency Inversion Principle",
        "DIP"
      ],
      "explanation": "Dependency Inversion depends on abstractions.",
      "id": "sol_pri_sol_pri_e_finals_004"
    },
    {
      "question": "What principle limits class responsibilities?",
      "answer": "Single Responsibility",
      "alternatives": [
        "SRP"
      ],
      "explanation": "Classes should have one reason to change.",
      "id": "sol_pri_sol_pri_e_finals_005"
    },
    {
      "question": "What principle enables extension without modification?",
      "answer": "Open/Closed",
      "alternatives": [
        "OCP"
      ],
      "explanation": "Extend behavior through inheritance and composition.",
      "id": "sol_pri_sol_pri_e_finals_006"
    },
    {
      "question": "What principle ensures subtype compatibility?",
      "answer": "Liskov Substitution",
      "alternatives": [
        "LSP"
      ],
      "explanation": "Subtypes must replace base types correctly.",
      "id": "sol_pri_sol_pri_e_finals_007"
    },
    {
      "question": "What principle prefers small interfaces?",
      "answer": "Interface Segregation",
      "alternatives": [
        "ISP"
      ],
      "explanation": "Clients should not depend on unused methods.",
      "id": "sol_pri_sol_pri_e_finals_008"
    },
    {
      "question": "What principle depends on abstractions?",
      "answer": "Dependency Inversion",
      "alternatives": [
        "DIP"
      ],
      "explanation": "High-level modules should not depend on low-level modules.",
      "id": "sol_pri_sol_pri_e_finals_009"
    }
  ]
}