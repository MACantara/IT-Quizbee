{
  "subtopic_id": "inheritance",
  "subtopic_name": "Inheritance",
  "mode": "finals",
  "difficulty": "difficult",
  "questions": [
    {
      "question": "What is virtual method?",
      "answer": "Method resolved at runtime",
      "alternatives": [
        "Dynamic dispatch"
      ],
      "explanation": "Virtual: decided at runtime. Compiler: doesn't know which version. Benefit: polymorphism. C++: explicit keyword. Java: all instance methods virtual. Importance: polymorphism mechanism."
    },
    {
      "question": "What is dynamic dispatch?",
      "answer": "Runtime method selection",
      "alternatives": [
        "Runtime polymorphism"
      ],
      "explanation": "Dispatch: choose method at runtime. Based on: actual object type. Implementation: virtual method table. Benefit: polymorphism. Performance: slight overhead. Importance: polymorphism mechanism."
    },
    {
      "question": "What is a virtual method table (vtable)?",
      "answer": "Table of virtual function pointers",
      "alternatives": [
        "Method lookup table"
      ],
      "explanation": "vtable: stored per class. Contains: function pointers. Lookup: fast O(1) operation. Creation: automatic by compiler. Overhead: memory for table. Importance: polymorphism implementation."
    },
    {
      "question": "What is RTTI (Runtime Type Information)?",
      "answer": "Identifying object type at runtime",
      "alternatives": [
        "Type identification"
      ],
      "explanation": "RTTI: query object type at runtime. Usage: type casting, type checking. Methods: isinstance(), typeid(). Benefit: dynamic behavior. Language: C++, Python support. Importance: runtime reflection."
    },
    {
      "question": "What is type casting in inheritance?",
      "answer": "Converting between parent and child types",
      "alternatives": [
        "Type conversion"
      ],
      "explanation": "Casting: explicit type conversion. Upcasting: child to parent (safe). Downcasting: parent to child (risky). Check: use instanceof first. Benefit: type flexibility. Importance: type management."
    },
    {
      "question": "What is the Liskov Substitution Principle?",
      "answer": "Subclass can substitute superclass",
      "alternatives": [
        "LSP"
      ],
      "explanation": "Principle: wherever parent expected, child works. Purpose: type safety. Violation: breaks polymorphism. Example: Square from Rectangle (breaks). Importance: inheritance correctness."
    },
    {
      "question": "What is fragile base class problem?",
      "answer": "Changes in base class break subclasses",
      "alternatives": [
        "Base class changes"
      ],
      "explanation": "Problem: modifying base class affects children. Example: add parameter to method. Issue: subclass methods become invalid. Solution: careful design. Importance: inheritance challenge."
    },
    {
      "question": "What is shallow inheritance?",
      "answer": "Few levels of inheritance",
      "alternatives": [
        "Limited hierarchy"
      ],
      "explanation": "Shallow: few parent-child levels. Benefit: simple, understandable. vs Deep: many levels. Balance: maintainability. Recommendation: keep shallow. Importance: design practice."
    },
    {
      "question": "What is deep inheritance?",
      "answer": "Many levels of class hierarchy",
      "alternatives": [
        "Deep hierarchy"
      ],
      "explanation": "Deep: multiple inheritance levels. Problem: hard to understand, maintain. Risk: complexity. Best practice: avoid deep. Preference: composition over inheritance. Importance: design consideration."
    },
    {
      "question": "What is mixins?",
      "answer": "Multiple inheritance to add functionality",
      "alternatives": [
        "Behavior mixing"
      ],
      "explanation": "Mixin: class providing methods. Purpose: add behavior without hierarchy. Usage: multiple inheritance. Alternative: traits, interfaces. Benefit: code reuse. Importance: inheritance pattern."
    }
  ]
}