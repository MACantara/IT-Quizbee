{
  "subtopic_id": "maintenance",
  "subtopic_name": "Software Maintenance",
  "mode": "finals",
  "difficulty": "difficult",
  "questions": [
    {
      "question": "What pattern intercepts calls to legacy systems without modification?",
      "answer": "Strangler Fig Pattern",
      "alternatives": ["Strangler Pattern"],
      "explanation": "Strangler Fig Pattern gradually replaces legacy systems by intercepting calls and routing to new implementations."
    },
    {
      "question": "What analyzes code complexity to predict maintenance effort?",
      "answer": "Complexity Analysis",
      "alternatives": ["Cyclomatic Complexity Analysis"],
      "explanation": "Complexity Analysis measures code intricacy using metrics like cyclomatic complexity to estimate maintenance costs."
    },
    {
      "question": "What law states software complexity increases unless work is done to reduce it?",
      "answer": "Lehman's Law",
      "alternatives": ["Laws of Software Evolution"],
      "explanation": "Lehman's Laws of Software Evolution describe how software systems evolve over time, including increasing complexity."
    },
    {
      "question": "What technique extracts reusable components from monolithic systems?",
      "answer": "Component Extraction",
      "alternatives": ["Service Extraction"],
      "explanation": "Component Extraction identifies and isolates reusable parts from legacy monoliths for modernization."
    },
    {
      "question": "What process converts procedural code to object-oriented design?",
      "answer": "Object-Oriented Re-engineering",
      "alternatives": ["OO Re-engineering"],
      "explanation": "Object-Oriented Re-engineering transforms procedural legacy code into object-oriented architecture."
    },
    {
      "question": "What metric calculates lines of code per defect?",
      "answer": "Defect Density",
      "alternatives": [],
      "explanation": "Defect Density measures the number of defects per thousand lines of code, indicating code quality."
    },
    {
      "question": "What strategy maintains multiple versions of software simultaneously?",
      "answer": "Parallel Maintenance",
      "alternatives": [],
      "explanation": "Parallel Maintenance involves supporting and fixing bugs across multiple active software versions."
    },
    {
      "question": "What technique mines historical data to predict maintenance needs?",
      "answer": "Predictive Maintenance",
      "alternatives": [],
      "explanation": "Predictive Maintenance analyzes patterns in historical data to anticipate and prevent future failures."
    },
    {
      "question": "What describes software no longer updated but still in use?",
      "answer": "End-of-Life Software",
      "alternatives": ["EOL Software"],
      "explanation": "End-of-Life Software has reached the end of its support lifecycle with no further updates or patches."
    },
    {
      "question": "What architecture pattern enables gradual migration from monolith to microservices?",
      "answer": "Anti-Corruption Layer",
      "alternatives": ["ACL"],
      "explanation": "Anti-Corruption Layer isolates legacy systems from new ones during migration, translating between different models."
    }
  ]
}