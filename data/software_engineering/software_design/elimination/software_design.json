{
  "subtopic_id": "software_design",
  "subtopic_name": "Software Design",
  "mode": "elimination",
  "questions": [
    {
      "question": "Which design principle states that a class should have only one reason to change?",
      "options": [
        "Open-Closed Principle",
        "Single Responsibility Principle",
        "Liskov Substitution Principle",
        "Interface Segregation Principle"
      ],
      "correct": 1,
      "explanation": "The Single Responsibility Principle states that a class should have only one reason to change, focusing on a single responsibility.",
      "id": "sof_eng_sof_des_elim_000"
    },
    {
      "question": "What architectural pattern separates an application into three interconnected components?",
      "options": [
        "MVC",
        "Layered Architecture",
        "Microservices",
        "Event-Driven"
      ],
      "correct": 0,
      "explanation": "Model-View-Controller (MVC) separates applications into Model (data), View (presentation), and Controller (logic) components.",
      "id": "sof_eng_sof_des_elim_001"
    },
    {
      "question": "Which design pattern ensures a class has only one instance?",
      "options": [
        "Factory",
        "Prototype",
        "Singleton",
        "Builder"
      ],
      "correct": 2,
      "explanation": "The Singleton pattern restricts class instantiation to a single instance and provides global access to it.",
      "id": "sof_eng_sof_des_elim_002"
    },
    {
      "question": "What does high cohesion in software design mean?",
      "options": [
        "Classes are tightly interconnected",
        "Related functionality is grouped together",
        "Modules have many dependencies",
        "Code is difficult to maintain"
      ],
      "correct": 1,
      "explanation": "High cohesion means related functionality is grouped together within a module, making it focused and maintainable.",
      "id": "sof_eng_sof_des_elim_003"
    },
    {
      "question": "Which design pattern provides a simplified interface to a complex subsystem?",
      "options": [
        "Adapter",
        "Bridge",
        "Facade",
        "Proxy"
      ],
      "correct": 2,
      "explanation": "The Facade pattern provides a simplified, unified interface to a complex subsystem, making it easier to use.",
      "id": "sof_eng_sof_des_elim_004"
    },
    {
      "question": "What is the primary goal of loose coupling?",
      "options": [
        "Increase dependencies between modules",
        "Reduce dependencies between modules",
        "Eliminate all interfaces",
        "Create tightly connected systems"
      ],
      "correct": 1,
      "explanation": "Loose coupling minimizes dependencies between modules, making the system more flexible and easier to maintain.",
      "id": "sof_eng_sof_des_elim_005"
    },
    {
      "question": "Which pattern allows incompatible interfaces to work together?",
      "options": [
        "Decorator",
        "Adapter",
        "Composite",
        "Bridge"
      ],
      "correct": 1,
      "explanation": "The Adapter pattern converts one interface to another, allowing incompatible classes to work together.",
      "id": "sof_eng_sof_des_elim_006"
    },
    {
      "question": "What architectural style is characterized by independent, deployable services?",
      "options": [
        "Monolithic",
        "Layered",
        "Microservices",
        "Client-Server"
      ],
      "correct": 2,
      "explanation": "Microservices architecture structures applications as collections of loosely coupled, independently deployable services.",
      "id": "sof_eng_sof_des_elim_007"
    },
    {
      "question": "Which design pattern separates abstraction from implementation?",
      "options": [
        "Bridge",
        "Proxy",
        "Decorator",
        "Composite"
      ],
      "correct": 0,
      "explanation": "The Bridge pattern decouples abstraction from implementation, allowing them to vary independently.",
      "id": "sof_eng_sof_des_elim_008"
    },
    {
      "question": "What does the DRY principle stand for?",
      "options": [
        "Develop Rapidly Yearly",
        "Don't Repeat Yourself",
        "Design Reusable Yields",
        "Data Requires Yielding"
      ],
      "correct": 1,
      "explanation": "DRY (Don't Repeat Yourself) principle states that every piece of knowledge should have a single representation in the system.",
      "id": "sof_eng_sof_des_elim_009"
    }
  ]
}