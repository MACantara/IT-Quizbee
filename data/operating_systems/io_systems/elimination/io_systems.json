{
  "subtopic_id": "io_systems",
  "subtopic_name": "I/O Systems",
  "mode": "elimination",
  "questions": [
    {
      "question": "What method has the CPU repeatedly check device status?",
      "options": [
        "Interrupt-driven I/O",
        "Polling",
        "DMA",
        "Asynchronous I/O"
      ],
      "correct": 1,
      "explanation": "Polling has the CPU continuously check device status. It's simple but wastes CPU cycles on busy waiting.",
      "id": "ope_sys_io_sys_elim_000"
    },
    {
      "question": "What mechanism notifies the CPU when I/O completes?",
      "options": [
        "Polling",
        "Interrupt",
        "Status register",
        "Command register"
      ],
      "correct": 1,
      "explanation": "Interrupts signal I/O completion to the CPU. They eliminate the need for continuous polling.",
      "id": "ope_sys_io_sys_elim_001"
    },
    {
      "question": "What technique transfers data directly between memory and device?",
      "options": [
        "Programmed I/O",
        "Interrupt-driven I/O",
        "DMA",
        "Memory-mapped I/O"
      ],
      "correct": 2,
      "explanation": "Direct Memory Access allows devices to transfer data without CPU involvement. It frees the CPU for other tasks.",
      "id": "ope_sys_io_sys_elim_002"
    },
    {
      "question": "What stores I/O data temporarily?",
      "options": [
        "Cache",
        "Buffer",
        "Register",
        "Queue"
      ],
      "correct": 1,
      "explanation": "Buffers hold I/O data temporarily. They accommodate speed differences between devices and processes.",
      "id": "ope_sys_io_sys_elim_003"
    },
    {
      "question": "What technique queues print jobs for later processing?",
      "options": [
        "Buffering",
        "Caching",
        "Spooling",
        "Scheduling"
      ],
      "correct": 2,
      "explanation": "Spooling queues output for devices that can't accept interleaved data. It's common for printers.",
      "id": "ope_sys_io_sys_elim_004"
    },
    {
      "question": "What software translates generic I/O commands to device-specific operations?",
      "options": [
        "Application",
        "Device driver",
        "BIOS",
        "Kernel"
      ],
      "correct": 1,
      "explanation": "Device drivers provide device-specific interfaces. They translate OS commands to hardware operations.",
      "id": "ope_sys_io_sys_elim_005"
    },
    {
      "question": "What addressing treats devices like memory locations?",
      "options": [
        "Port-mapped I/O",
        "Memory-mapped I/O",
        "DMA",
        "Interrupt-driven I/O"
      ],
      "correct": 1,
      "explanation": "Memory-mapped I/O assigns devices memory addresses. The CPU uses standard memory instructions for I/O.",
      "id": "ope_sys_io_sys_elim_006"
    },
    {
      "question": "What channel type handles multiple low-speed devices?",
      "options": [
        "Selector channel",
        "Multiplexor channel",
        "Block channel",
        "Stream channel"
      ],
      "correct": 1,
      "explanation": "Multiplexor channels interleave I/O from multiple slow devices. They share channel bandwidth efficiently.",
      "id": "ope_sys_io_sys_elim_007"
    },
    {
      "question": "What small region transfers data during disk I/O?",
      "options": [
        "Block",
        "Sector",
        "Track",
        "Cylinder"
      ],
      "correct": 1,
      "explanation": "Sectors are disk's smallest addressable units. Disks read and write entire sectors.",
      "id": "ope_sys_io_sys_elim_008"
    },
    {
      "question": "What redundancy technique improves disk reliability?",
      "options": [
        "Caching",
        "RAID",
        "Buffering",
        "Spooling"
      ],
      "correct": 1,
      "explanation": "RAID combines multiple disks for redundancy and performance. Different levels provide various trade-offs.",
      "id": "ope_sys_io_sys_elim_009"
    }
  ]
}