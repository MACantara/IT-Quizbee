{
  "subtopic_id": "abstraction",
  "subtopic_name": "Abstraction",
  "mode": "finals",
  "difficulty": "difficult",
  "questions": [
    {
      "question": "What prevents instantiation of abstract classes in C++?",
      "answer": "pure virtual functions",
      "alternatives": ["pure virtual"],
      "explanation": "Pure virtual functions make classes abstract."
    },
    {
      "question": "What Python metaclass creates abstract base classes?",
      "answer": "ABCMeta",
      "alternatives": ["ABC metaclass"],
      "explanation": "ABCMeta enforces abstract method implementation."
    },
    {
      "question": "What principle separates concerns through abstraction?",
      "answer": "separation of concerns",
      "alternatives": ["SoC"],
      "explanation": "Separation of concerns isolates different aspects."
    },
    {
      "question": "What pattern provides simplified interface to complex subsystems?",
      "answer": "facade pattern",
      "alternatives": ["facade"],
      "explanation": "Facade pattern creates unified interface."
    },
    {
      "question": "What allows runtime selection of algorithms?",
      "answer": "strategy pattern",
      "alternatives": ["strategy"],
      "explanation": "Strategy pattern encapsulates interchangeable algorithms."
    },
    {
      "question": "What abstraction level defines data structures?",
      "answer": "conceptual level",
      "alternatives": ["conceptual abstraction"],
      "explanation": "Conceptual level describes entities and relationships."
    },
    {
      "question": "What Java 8 feature adds abstraction flexibility?",
      "answer": "default methods",
      "alternatives": ["defender methods"],
      "explanation": "Default methods allow interface evolution."
    },
    {
      "question": "What pattern defines interface for creating objects?",
      "answer": "factory pattern",
      "alternatives": ["factory"],
      "explanation": "Factory pattern abstracts object creation."
    },
    {
      "question": "What principle programs to interfaces not implementations?",
      "answer": "dependency inversion",
      "alternatives": ["Dependency Inversion Principle", "DIP"],
      "explanation": "Dependency inversion promotes abstraction over concretion."
    },
    {
      "question": "What abstraction technique separates interface specification?",
      "answer": "information hiding",
      "alternatives": ["data hiding"],
      "explanation": "Information hiding encapsulates implementation details."
    }
  ]
}