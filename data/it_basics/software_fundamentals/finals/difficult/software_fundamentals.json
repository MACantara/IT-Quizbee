{
  "subtopic_id": "software_fundamentals",
  "subtopic_name": "Software Fundamentals",
  "mode": "finals",
  "difficulty": "difficult",
  "questions": [
    {
      "question": "What is SDLC?",
      "answer": "Software Development Life Cycle",
      "alternatives": [
        "Development process"
      ],
      "explanation": "SDLC: structured development process. Phases: planning, design, development, testing, deployment, maintenance. Models: waterfall, agile, DevOps. Purpose: quality, organization. Importance: project success critical."
    },
    {
      "question": "What is version control?",
      "answer": "Track code changes over time",
      "alternatives": [
        "Source control"
      ],
      "explanation": "Version control: history of modifications. Tools: Git, SVN. Branches: parallel development. Merging: integrate changes. Collaboration: essential for teams. Importance: code management critical."
    },
    {
      "question": "What is refactoring?",
      "answer": "Improving code structure without changing behavior",
      "alternatives": [
        "Code improvement"
      ],
      "explanation": "Refactoring: restructure for readability, performance. Purpose: maintainability, reduce debt. Testing: critical before/after. Iteration: continuous process. Benefit: long-term sustainability."
    },
    {
      "question": "What is code review?",
      "answer": "Peer evaluation of code changes",
      "alternatives": [
        "Peer review"
      ],
      "explanation": "Code review: quality assurance technique. Purpose: bug detection, knowledge sharing. Process: collaborative feedback. Tools: GitHub, GitLab. Benefit: improves code quality, team learning."
    },
    {
      "question": "What is debugging?",
      "answer": "Finding and fixing software errors",
      "alternatives": [
        "Error correction"
      ],
      "explanation": "Debugging: systematic error finding. Tools: debuggers, logging. Methods: breakpoints, inspection. Purpose: software correctness. Skill: critical for developers. Process: often time-consuming."
    },
    {
      "question": "What is unit testing?",
      "answer": "Testing individual code components",
      "alternatives": [
        "Component testing"
      ],
      "explanation": "Unit testing: tests smallest testable units. Framework: JUnit, pytest typical. Coverage: measure of completeness. Automation: continuous integration. Benefit: catches bugs early."
    },
    {
      "question": "What is integration testing?",
      "answer": "Testing combined component interactions",
      "alternatives": [
        "Component interaction test"
      ],
      "explanation": "Integration testing: tests system parts together. Purpose: verify interfaces work. Scope: larger than unit tests. Complexity: more involved than unit tests. Detection: interface bugs."
    },
    {
      "question": "What is deployment?",
      "answer": "Releasing software to production",
      "alternatives": [
        "Software release"
      ],
      "explanation": "Deployment: moving software to live environment. Planning: important for success. Rollback: ability to revert if problems. Automation: CI/CD pipelines. Risk: minimize with testing."
    },
    {
      "question": "What is technical debt?",
      "answer": "Quick fixes that require later rework",
      "alternatives": [
        "Code debt"
      ],
      "explanation": "Technical debt: accumulated shortcuts. Impact: future maintenance burden. Causes: time pressure, poor planning. Payoff: refactoring, rewriting. Management: crucial for sustainability."
    },
    {
      "question": "What is continuous integration?",
      "answer": "Automating code merge and testing",
      "alternatives": [
        "CI/CD process"
      ],
      "explanation": "CI: automated build and test pipeline. Purpose: catch bugs early, maintain quality. Tools: Jenkins, GitHub Actions. Frequency: multiple times daily. Benefit: reduce integration problems."
    }
  ]
}