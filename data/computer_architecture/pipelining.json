{
  "subtopic_id": "pipelining",
  "subtopic_name": "Pipelining",
  "questions": [
    {
      "question": "What is instruction pipelining in computer architecture?",
      "options": [
        "Storing instructions in a queue for later execution",
        "A technique where multiple instruction stages are overlapped to improve throughput",
        "Connecting multiple processors in series",
        "Compressing instructions to save memory"
      ],
      "correct": 1,
      "explanation": "Instruction pipelining is a technique where instruction execution is divided into stages (fetch, decode, execute, memory access, write-back), and multiple instructions are processed simultaneously at different stagesâ€”like an assembly line. While one instruction executes, another decodes, and another fetches, increasing CPU throughput without increasing clock speed."
    },
    {
      "question": "What are the typical stages in a classic RISC pipeline?",
      "options": [
        "Start, Middle, End",
        "Fetch, Decode, Execute, Memory, Write-back",
        "Input, Process, Output",
        "Load, Store, Execute"
      ],
      "correct": 1,
      "explanation": "The classic 5-stage RISC pipeline consists of: 1) Fetch (IF - retrieve instruction from memory), 2) Decode (ID - interpret instruction and read registers), 3) Execute (EX - perform ALU operation), 4) Memory (MEM - access data memory if needed), 5) Write-back (WB - write results to registers). Each stage takes one clock cycle."
    },
    {
      "question": "What is a pipeline hazard?",
      "options": [
        "Physical damage to the processor",
        "A situation that prevents the next instruction from executing in its designated clock cycle",
        "A security vulnerability in the pipeline",
        "Overheating of the CPU"
      ],
      "correct": 1,
      "explanation": "A pipeline hazard is a situation that prevents an instruction from executing during its designated clock cycle, causing stalls (bubbles) in the pipeline and reducing performance. There are three types: structural hazards (resource conflicts), data hazards (dependencies between instructions), and control hazards (branch instructions changing program flow)."
    },
    {
      "question": "What is a data hazard in pipelining?",
      "options": [
        "Corruption of data in memory",
        "When an instruction depends on the result of a previous instruction still in the pipeline",
        "When data is too large to fit in registers",
        "When the hard drive fails"
      ],
      "correct": 1,
      "explanation": "A data hazard occurs when an instruction needs data that a previous instruction hasn't yet written (Read After Write - RAW), or less commonly, Write After Read (WAR) or Write After Write (WAW). Example: ADD R1, R2, R3 followed by SUB R4, R1, R5 creates a hazard because SUB needs R1 before ADD writes it. Solutions include forwarding/bypassing or pipeline stalls."
    },
    {
      "question": "What is data forwarding (bypassing) in pipelining?",
      "options": [
        "Skipping unnecessary instructions",
        "Passing results directly from one stage to another before they're written to registers",
        "Sending data to external storage",
        "Compressing data to reduce size"
      ],
      "correct": 1,
      "explanation": "Data forwarding (or bypassing) resolves data hazards by passing the result of an instruction directly from the execution stage to a subsequent instruction that needs it, without waiting for it to be written to registers and read back. This eliminates or reduces pipeline stalls, improving performance while maintaining correct execution."
    },
    {
      "question": "What is a control hazard in pipelining?",
      "options": [
        "When the control unit malfunctions",
        "Uncertainty about which instruction to fetch next due to branch instructions",
        "When there are too many control signals",
        "Loss of control over the processor"
      ],
      "correct": 1,
      "explanation": "Control hazards occur with branch instructions (if statements, loops) because the pipeline must decide which instruction to fetch next before knowing if the branch will be taken. This can cause wasted work if wrong instructions are fetched. Solutions include branch prediction, delayed branches, and flushing the pipeline when predictions are wrong."
    },
    {
      "question": "What is branch prediction?",
      "options": [
        "Predicting which branch of code will have bugs",
        "Guessing whether a branch instruction will be taken to continue fetching instructions",
        "Organizing code into branches",
        "Predicting program execution time"
      ],
      "correct": 1,
      "explanation": "Branch prediction is a technique where the CPU predicts whether a conditional branch will be taken or not and speculatively fetches instructions based on that prediction. Static prediction uses fixed rules; dynamic prediction uses history (branch history table). Good prediction (>95% accuracy) minimizes pipeline stalls. Wrong predictions require flushing the pipeline."
    },
    {
      "question": "What is a pipeline stall (bubble)?",
      "options": [
        "Air trapped in cooling pipes",
        "An idle cycle in the pipeline where no useful work is done due to a hazard",
        "A backup of instructions",
        "A type of cache miss"
      ],
      "correct": 1,
      "explanation": "A pipeline stall or bubble is when one or more stages of the pipeline are idle (doing nothing) because a hazard prevents progress. For example, a data dependency might force the decode stage to wait for data, creating a 'bubble' that propagates through the pipeline. Stalls reduce the performance benefits of pipelining."
    },
    {
      "question": "What is pipeline depth?",
      "options": [
        "How deep the pipeline is buried in the chip",
        "The number of stages in the pipeline",
        "The amount of data the pipeline can hold",
        "The physical length of the pipeline"
      ],
      "correct": 1,
      "explanation": "Pipeline depth refers to the number of stages in the pipeline. Deeper pipelines (more stages) can achieve higher clock frequencies because each stage does less work, but they're more susceptible to hazards and have longer misprediction penalties. Modern processors have 10-20+ stages. There's a trade-off between depth and complexity."
    },
    {
      "question": "What is superscalar execution?",
      "options": [
        "Executing instructions at very high speeds",
        "A processor that can issue and execute multiple instructions per clock cycle using multiple pipelines",
        "Using multiple processors in parallel",
        "Executing only the most important instructions"
      ],
      "correct": 1,
      "explanation": "Superscalar processors have multiple execution units and can issue/execute multiple instructions simultaneously in a single clock cycle (instruction-level parallelism). For example, a dual-issue processor might execute two independent instructions per cycle using separate ALUs. This requires sophisticated hardware to detect dependencies and schedule instructions, going beyond simple pipelining."
    }
  ]
}