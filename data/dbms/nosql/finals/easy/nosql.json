{
  "subtopic_id": "nosql",
  "subtopic_name": "NoSQL Databases",
  "mode": "finals",
  "difficulty": "easy",
  "questions": [
    {
      "question": "What data models relational databases?",
      "answer": "Relational model",
      "alternatives": [
        "SQL"
      ],
      "explanation": "Relational model: data in tables (rows, columns). Structured schema, ACID, SQL. Excellent consistency, some flexibility trade-off. Best for: structured data, transactions. Overhead: schema changes, scaling complexity. Traditional choice for business applications."
    },
    {
      "question": "What non-relational database stores documents?",
      "answer": "Document database",
      "alternatives": [
        "MongoDB",
        "JSON store"
      ],
      "explanation": "Document database stores JSON/BSON documents. Flexible schema: different documents different fields. Example: MongoDB. Queries: nested path, array access. Good for: semi-structured data, prototype development, rapid iteration. Challenges: consistency control, complex joins."
    },
    {
      "question": "What stores key-value pairs?",
      "answer": "Key-value store",
      "alternatives": [
        "Redis",
        "Memcached"
      ],
      "explanation": "Key-value store: keys map to values (strings, objects, lists). Simple API: GET, SET, DELETE. Fast in-memory access. Example: Redis, Memcached. Use cases: caching, sessions, counters, leaderboards. Limitations: no query language, limited structure."
    },
    {
      "question": "What organizes entities and relationships?",
      "answer": "Graph database",
      "alternatives": [
        "Neo4j"
      ],
      "explanation": "Graph database represents entities as nodes, relationships as edges. Efficient traversal: relationships stored directly. Example: Neo4j. Use cases: social networks, recommendations, knowledge graphs, identity/access management. Queries: path finding, pattern matching."
    },
    {
      "question": "What database has no fixed schema?",
      "answer": "Schema-flexible",
      "alternatives": [
        "Flexible schema",
        "Dynamic schema"
      ],
      "explanation": "Schema-flexible: add/remove fields without migration. Documents can have different structures. Example: MongoDB document variations. Advantage: agility, prototyping. Disadvantage: inconsistency, application validation needed. Contrast: relational rigid schema."
    },
    {
      "question": "What stores data across multiple servers?",
      "answer": "Distributed database",
      "alternatives": [
        "Sharded",
        "Horizontally scaled"
      ],
      "explanation": "Distributed database: data partitioned across servers for scale. Enables: parallel processing, fault tolerance. Challenges: consistency (CAP theorem), complexity. Examples: Cassandra, Dynamo. Trade-off: availability/partition tolerance vs. consistency."
    },
    {
      "question": "What divides data by range or hash?",
      "answer": "Sharding",
      "alternatives": [
        "Horizontal partitioning"
      ],
      "explanation": "Sharding: data distributed across shards (servers) by key. Range sharding: contiguous ranges. Hash sharding: hash(key) determines shard. Benefits: horizontal scale, parallel queries. Challenges: hotspots, rebalancing, transactions. Different from replication."
    },
    {
      "question": "What describes all nodes identical copies?",
      "answer": "Replication",
      "alternatives": [
        "Redundancy"
      ],
      "explanation": "Replication: copies of data on multiple nodes. Master-slave: master writes, slaves read. Multi-master: all write. Benefits: fault tolerance, read scale. Challenges: consistency, eventual consistency delays. Different from sharding (redundancy vs. distribution)."
    },
    {
      "question": "What guarantees availability of partitioned data?",
      "answer": "CAP theorem",
      "alternatives": [
        "Brewer's theorem"
      ],
      "explanation": "CAP theorem: Can't have all three: Consistency (all nodes same), Availability (always respond), Partition tolerance (survive splits). Choose 2. CP: strong consistency but unavailable on split. AP: always available but eventual consistency. Trade-off fundamental."
    },
    {
      "question": "What accepts temporary consistency delays?",
      "answer": "Eventual consistency",
      "alternatives": [
        "Weak consistency"
      ],
      "explanation": "Eventual consistency: replicas eventually converge, not immediately. Allows: better availability, lower latency. Example: read-your-own-write after delay. Trade-off: short windows of inconsistency. Acceptable for: caches, social feeds, analytics. Not for financial data."
    }
  ]
}