{
  "subtopic_id": "polymorphism",
  "subtopic_name": "Polymorphism",
  "mode": "finals",
  "difficulty": "difficult",
  "questions": [
    {
      "question": "What pattern allows operations on object structures?",
      "answer": "visitor pattern",
      "alternatives": [
        "visitor"
      ],
      "explanation": "Visitor pattern separates algorithms from object structure.",
      "id": "poly_poly_d_finals_000"
    },
    {
      "question": "What technique resolves ambiguity in multiple dispatch?",
      "answer": "double dispatch",
      "alternatives": [
        "dual dispatch"
      ],
      "explanation": "Double dispatch uses two method calls for resolution.",
      "id": "poly_poly_d_finals_001"
    },
    {
      "question": "What allows return types to vary in overridden methods?",
      "answer": "covariant return types",
      "alternatives": [
        "covariance"
      ],
      "explanation": "Covariant returns support more specific types in subclasses.",
      "id": "poly_poly_d_finals_002"
    },
    {
      "question": "What allows parameter types to vary in method overrides?",
      "answer": "contravariance",
      "alternatives": [
        "contravariant parameters"
      ],
      "explanation": "Contravariance allows more general parameter types.",
      "id": "poly_poly_d_finals_003"
    },
    {
      "question": "What C++ feature allows template specialization?",
      "answer": "template specialization",
      "alternatives": [
        "explicit specialization"
      ],
      "explanation": "Specialization customizes templates for specific types.",
      "id": "poly_poly_d_finals_004"
    },
    {
      "question": "What technique resolves virtual function calls?",
      "answer": "vtable lookup",
      "alternatives": [
        "virtual table lookup"
      ],
      "explanation": "Vtable lookup finds the correct function at runtime.",
      "id": "poly_poly_d_finals_005"
    },
    {
      "question": "What pattern uses polymorphism to create object families?",
      "answer": "abstract factory",
      "alternatives": [
        "abstract factory pattern"
      ],
      "explanation": "Abstract factory creates related objects polymorphically.",
      "id": "poly_poly_d_finals_006"
    },
    {
      "question": "What allows Python to simulate method overloading?",
      "answer": "default arguments",
      "alternatives": [
        "default parameters"
      ],
      "explanation": "Default arguments provide similar functionality.",
      "id": "poly_poly_d_finals_007"
    },
    {
      "question": "What dispatches based on multiple argument types?",
      "answer": "multiple dispatch",
      "alternatives": [
        "multimethods"
      ],
      "explanation": "Multiple dispatch selects methods based on all arguments.",
      "id": "poly_poly_d_finals_008"
    },
    {
      "question": "What principle ensures behavioral substitutability?",
      "answer": "Liskov Substitution Principle",
      "alternatives": [
        "LSP"
      ],
      "explanation": "LSP maintains correctness when substituting subtypes.",
      "id": "poly_poly_d_finals_009"
    }
  ]
}