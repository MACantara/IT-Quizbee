{
  "subtopic_id": "advanced_oop",
  "subtopic_name": "Advanced OOP",
  "mode": "finals",
  "difficulty": "difficult",
  "questions": [
    {
      "question": "What is the phantom type pattern?",
      "answer": "Type parameter with no runtime value",
      "alternatives": [
        "Phantom type"
      ],
      "explanation": "Phantom: exists in type only. Purpose: compile-time safety. Benefit: prevent misuse. Example: strongly-typed tags. Importance: advanced pattern."
    },
    {
      "question": "What is the typeclass pattern?",
      "answer": "Define behavior for types without inheritance",
      "alternatives": [
        "Type behavior"
      ],
      "explanation": "Typeclass: ad-hoc polymorphism. Purpose: no inheritance needed. Language: Haskell, Scala. Example: Show typeclass. Importance: advanced pattern."
    },
    {
      "question": "What is the monad pattern?",
      "answer": "Encapsulate computational pattern",
      "alternatives": [
        "Computation wrapper"
      ],
      "explanation": "Monad: FP pattern. Purpose: computation abstraction. Language: Haskell. Benefit: compose operations. Importance: FP pattern."
    },
    {
      "question": "What is the functor pattern?",
      "answer": "Map function over container",
      "alternatives": [
        "Container mapping"
      ],
      "explanation": "Functor: map operation. Purpose: structure preservation. Language: Haskell, Category Theory. Benefit: abstract. Importance: FP pattern."
    },
    {
      "question": "What is compile-time reflection?",
      "answer": "Reflection resolved at compile time",
      "alternatives": [
        "Compile-time inspection"
      ],
      "explanation": "Compile-time: static. Purpose: performance. Benefit: no runtime overhead. Language: C++ templates. Importance: performance technique."
    },
    {
      "question": "What is the self-type pattern?",
      "answer": "Type that refers to itself",
      "alternatives": [
        "Self reference"
      ],
      "explanation": "Self-type: type referring to itself. Purpose: chainable builders. Benefit: typed fluent. Example: return this. Importance: pattern."
    },
    {
      "question": "What is the singleton pattern with thread safety?",
      "answer": "Ensure single instance in concurrent environment",
      "alternatives": [
        "Thread-safe singleton"
      ],
      "explanation": "Thread-safe: synchronization. Methods: double-checked locking, eager init. Language: Java. Importance: concurrency."
    },
    {
      "question": "What is the difference between static and dynamic typing?",
      "answer": "Static at compile-time, dynamic at runtime",
      "alternatives": [
        "Type systems"
      ],
      "explanation": "Static: compile checks. Dynamic: runtime checks. Tradeoff: safety vs flexibility. Example: Java vs Python. Importance: language feature."
    },
    {
      "question": "What is gradual typing?",
      "answer": "Mix static and dynamic typing",
      "alternatives": [
        "Mixed typing"
      ],
      "explanation": "Gradual: both types. Purpose: flexibility. Benefit: choose per variable. Language: TypeScript, Python (type hints). Importance: modern feature."
    },
    {
      "question": "What is the curiously recurring template pattern (CRTP)?",
      "answer": "Derive from template of itself",
      "alternatives": [
        "CRTP"
      ],
      "explanation": "CRTP: Base<Derived>. Purpose: static polymorphism. Benefit: performance. Language: C++. Importance: advanced technique."
    }
  ]
}