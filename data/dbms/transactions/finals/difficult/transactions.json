{
  "subtopic_id": "transactions",
  "subtopic_name": "Transactions",
  "mode": "finals",
  "difficulty": "difficult",
  "questions": [
    {
      "question": "A schedule equivalent to some serial schedule in terms of final database state.",
      "answer": "Serializable schedule",
      "alternatives": [],
      "explanation": "A serializable schedule produces the same result as some serial execution of transactions."
    },
    {
      "question": "Two schedules that produce the same final database state are said to be this.",
      "answer": "Result equivalent",
      "alternatives": [],
      "explanation": "Result equivalence means schedules produce identical final states regardless of intermediate steps."
    },
    {
      "question": "Schedules where all conflicting operations are ordered the same way.",
      "answer": "Conflict equivalent",
      "alternatives": ["Conflict serializable"],
      "explanation": "Conflict-equivalent schedules have the same ordering of all conflicting operations between transactions."
    },
    {
      "question": "A directed graph used to test for conflict serializability by detecting cycles.",
      "answer": "Precedence graph",
      "alternatives": ["Serialization graph"],
      "explanation": "A precedence graph shows transaction dependencies; a cycle indicates non-serializability."
    },
    {
      "question": "The strictest variant of two-phase locking that holds all locks until transaction commit.",
      "answer": "Strict two-phase locking",
      "alternatives": ["Strict 2PL"],
      "explanation": "Strict 2PL holds all exclusive locks until commit, preventing cascading rollbacks."
    },
    {
      "question": "The most restrictive form of two-phase locking that holds all locks until commit.",
      "answer": "Rigorous two-phase locking",
      "alternatives": ["Rigorous 2PL"],
      "explanation": "Rigorous 2PL holds all locks (shared and exclusive) until transaction completion."
    },
    {
      "question": "A deadlock detection technique that checks for cycles in a wait-for graph.",
      "answer": "Wait-for graph",
      "alternatives": [],
      "explanation": "A wait-for graph represents which transactions are waiting for others; cycles indicate deadlock."
    },
    {
      "question": "Deadlock prevention by assigning timestamps and aborting younger transactions.",
      "answer": "Wait-die scheme",
      "alternatives": [],
      "explanation": "In wait-die, older transactions wait for younger ones; younger transactions are aborted."
    },
    {
      "question": "Deadlock prevention where younger transactions wait and older ones are rolled back.",
      "answer": "Wound-wait scheme",
      "alternatives": [],
      "explanation": "In wound-wait, younger transactions wait for older ones; older transactions preempt younger ones."
    },
    {
      "question": "Concurrency control using transaction timestamps rather than locks.",
      "answer": "Timestamp ordering",
      "alternatives": [],
      "explanation": "Timestamp ordering assigns timestamps to transactions and orders operations based on them."
    }
  ]
}