{
  "subtopic_id": "number_systems",
  "subtopic_name": "Number Systems",
  "mode": "finals",
  "difficulty": "average",
  "questions": [
    {
      "question": "How do you convert binary to decimal?",
      "answer": "Multiply each bit by power of 2, sum results",
      "alternatives": [
        "Positional notation"
      ],
      "explanation": "Binary conversion: each position = power of 2. Example: 1101 = 1*8 + 1*4 + 0*2 + 1*1 = 13. Right: least significant bit (LSB). Left: most significant bit (MSB). Process: straightforward, systematic. Verification: convert back to check."
    },
    {
      "question": "How do you convert decimal to binary?",
      "answer": "Repeatedly divide by 2, note remainders",
      "alternatives": [
        "Division method"
      ],
      "explanation": "Decimal conversion: divide by 2, remainder = bit. Repeat: with quotient. Read: remainders backwards. Example: 13  1101. Verification: convert back confirms. Process: mechanical, reliable. Alternative: use powers of 2."
    },
    {
      "question": "What is two's complement?",
      "answer": "Binary negative number representation",
      "alternatives": [
        "Signed integer method"
      ],
      "explanation": "Two's complement: represents negatives in binary. Process: invert bits, add 1. Example: -5 as 8-bit = 11111011. Advantage: simplifies arithmetic, single representation for zero. Standard: universal computing standard."
    },
    {
      "question": "What is one's complement?",
      "answer": "Alternate negative representation",
      "alternatives": [
        "Older sign method"
      ],
      "explanation": "One's complement: simply invert all bits. Example: -5 as 8-bit = 11111010. Disadvantage: two zeros (+0, -0). Deprecated: replaced by two's complement. Historical: some systems used."
    },
    {
      "question": "What is the sign bit?",
      "answer": "Most significant bit indicating sign",
      "alternatives": [
        "MSB sign indicator"
      ],
      "explanation": "Sign bit: leftmost bit in signed integer. 0: positive number. 1: negative number (two's complement). Range: affects maximum/minimum values. Standard: universal in signed arithmetic."
    },
    {
      "question": "What is logical AND?",
      "answer": "Both bits must be 1",
      "alternatives": [
        "Boolean AND"
      ],
      "explanation": "AND operation: 1 only if both true. Truth: 1&1=1, all others=0. Uses: masking, checking flags. Notation: & symbol. Example: 1101 & 1010 = 1000. Hardware: simple gate."
    },
    {
      "question": "What is logical OR?",
      "answer": "Either bit being 1",
      "alternatives": [
        "Boolean OR"
      ],
      "explanation": "OR operation: 1 if either true. Truth: 0 only if both false. Uses: setting flags, combining options. Notation: | symbol. Example: 1100 | 1010 = 1110. Hardware: simple gate."
    },
    {
      "question": "What is logical XOR?",
      "answer": "Bits different means 1",
      "alternatives": [
        "Exclusive OR"
      ],
      "explanation": "XOR operation: 1 if bits differ. Truth: different=1, same=0. Uses: parity, encryption, toggle. Notation: ^ symbol. Example: 1100 ^ 1010 = 0110. Hardware: useful in circuits."
    },
    {
      "question": "What is logical NOT?",
      "answer": "Inverts all bits",
      "alternatives": [
        "Bitwise complement"
      ],
      "explanation": "NOT operation: 01, 10. Notation: ~ symbol. Uses: complementation, creating masks. Example: ~1100 = 0011 (4-bit). Relationship: part of two's complement. Hardware: simple inverter gate."
    },
    {
      "question": "What is endianness?",
      "answer": "Byte order in multi-byte integers",
      "alternatives": [
        "Byte ordering"
      ],
      "explanation": "Endianness: big vs little endian. Big: most significant byte first. Little: least significant byte first. Example: 0x12345678 stored differently. Importance: network, file compatibility. Detection: varies by processor architecture."
    }
  ]
}