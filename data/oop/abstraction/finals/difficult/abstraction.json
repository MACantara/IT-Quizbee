{
  "subtopic_id": "abstraction",
  "subtopic_name": "Abstraction",
  "mode": "finals",
  "difficulty": "difficult",
  "questions": [
    {
      "question": "What is invariant?",
      "answer": "Condition always true for object",
      "alternatives": [
        "Object invariant"
      ],
      "explanation": "Invariant: must maintain. Purpose: correctness. Example: balance >= 0 for bank account. Enforcement: constructor and methods. Importance: correctness specification."
    },
    {
      "question": "What is a precondition?",
      "answer": "Condition required before method",
      "alternatives": [
        "Method requirement"
      ],
      "explanation": "Precondition: must be true at start. Caller: responsible for ensuring. Benefit: simplify method. Example: index >= 0. Documentation: document preconditions. Importance: contract programming."
    },
    {
      "question": "What is a postcondition?",
      "answer": "Condition guaranteed after method",
      "alternatives": [
        "Method guarantee"
      ],
      "explanation": "Postcondition: true after execution. Method: guarantees result. Benefit: document effect. Example: list.size() increased. Documentation: document postconditions. Importance: contract programming."
    },
    {
      "question": "What is design by contract?",
      "answer": "Formalize interface agreements",
      "alternatives": [
        "Contract programming"
      ],
      "explanation": "Contract: preconditions, postconditions, invariants. Benefit: clear expectations. Language: Eiffel, Java (via assertions). Purpose: correctness. Importance: formal method."
    },
    {
      "question": "What is a private inner class?",
      "answer": "Nested class with private access",
      "alternatives": [
        "Inner class"
      ],
      "explanation": "Inner: nested inside class. Private: only outer class sees. Purpose: abstraction, hide helpers. Benefit: encapsulation. Example: iterator implementations. Importance: advanced encapsulation."
    },
    {
      "question": "What is method hiding?",
      "answer": "Static method overrides (not overridden)",
      "alternatives": [
        "Static override"
      ],
      "explanation": "Hiding: static methods not overridden. Purpose: compile-time binding. Distinction: overriding is runtime. Benefit: avoid confusion. Importance: method resolution."
    },
    {
      "question": "What is sealed class?",
      "answer": "Restrict which classes extend it",
      "alternatives": [
        "Class restriction"
      ],
      "explanation": "Sealed: limit subclasses. Purpose: control hierarchy. Implementation: sealed keyword (Java 17+). Benefit: design control. Example: limiting extensions. Importance: advanced feature."
    },
    {
      "question": "What is the law of Demeter?",
      "answer": "Object knows only immediate neighbors",
      "alternatives": [
        "Demeter principle"
      ],
      "explanation": "Law: minimize coupling. Rules: call methods of same object, parameters, results. Violation: a.b.c.d(). Benefit: loose coupling. Importance: design principle."
    },
    {
      "question": "What is coupling?",
      "answer": "Degree of dependence between modules",
      "alternatives": [
        "Module dependence"
      ],
      "explanation": "Coupling: tight vs loose. Tight: high interdependence. Loose: low interdependence. Goal: minimize coupling. Benefit: flexibility. Importance: design metric."
    },
    {
      "question": "What is cohesion?",
      "answer": "Degree of relatedness within module",
      "alternatives": [
        "Module relatedness"
      ],
      "explanation": "Cohesion: high vs low. High: related functionality grouped. Low: unrelated items grouped. Goal: maximize cohesion. Benefit: understandability. Importance: design metric."
    }
  ]
}