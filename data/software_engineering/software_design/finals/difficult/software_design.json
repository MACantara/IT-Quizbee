{
  "subtopic_id": "software_design",
  "subtopic_name": "Software Design",
  "mode": "finals",
  "difficulty": "difficult",
  "questions": [
    {
      "question": "The SOLID principle stating clients shouldn't depend on interfaces they don't use.",
      "answer": "Interface Segregation Principle",
      "alternatives": ["ISP"],
      "explanation": "ISP states that clients should not be forced to depend on interfaces they don't use; split interfaces appropriately."
    },
    {
      "question": "The SOLID principle advocating dependency on abstractions rather than concrete implementations.",
      "answer": "Dependency Inversion Principle",
      "alternatives": ["DIP"],
      "explanation": "DIP states high-level modules shouldn't depend on low-level modules; both should depend on abstractions."
    },
    {
      "question": "The architectural pattern where components communicate through a central mediator.",
      "answer": "Mediator Pattern",
      "alternatives": ["Mediator"],
      "explanation": "Mediator pattern centralizes complex communications and control logic between related objects."
    },
    {
      "question": "The design pattern that provides access to elements of a collection sequentially.",
      "answer": "Iterator",
      "alternatives": ["Iterator Pattern"],
      "explanation": "Iterator pattern provides a way to access elements of a collection sequentially without exposing its structure."
    },
    {
      "question": "The design pattern that captures and externalizes object state for later restoration.",
      "answer": "Memento",
      "alternatives": ["Memento Pattern"],
      "explanation": "Memento pattern captures an object's internal state to enable undo or rollback operations."
    },
    {
      "question": "The architectural style with asynchronous message passing between components.",
      "answer": "Event-Driven Architecture",
      "alternatives": ["EDA", "Message-Driven"],
      "explanation": "Event-driven architecture uses events to trigger and communicate between decoupled services."
    },
    {
      "question": "The pattern that composes objects into tree structures for part-whole hierarchies.",
      "answer": "Composite",
      "alternatives": ["Composite Pattern"],
      "explanation": "Composite pattern lets clients treat individual objects and compositions uniformly through tree structures."
    },
    {
      "question": "The design pattern that provides a way to access object elements without exposing structure.",
      "answer": "Visitor",
      "alternatives": ["Visitor Pattern"],
      "explanation": "Visitor pattern separates algorithms from the objects they operate on by adding operations externally."
    },
    {
      "question": "The architectural pattern separating read and write operations for scalability.",
      "answer": "CQRS",
      "alternatives": ["Command Query Responsibility Segregation"],
      "explanation": "CQRS separates read and write models to optimize performance, scalability, and security independently."
    },
    {
      "question": "The principle stating prefer object composition over class inheritance.",
      "answer": "Composition Over Inheritance",
      "alternatives": ["Favor Composition"],
      "explanation": "This principle advocates using object composition for flexibility rather than rigid inheritance hierarchies."
    }
  ]
}