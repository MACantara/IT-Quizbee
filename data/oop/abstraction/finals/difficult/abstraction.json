{
  "subtopic_id": "abstraction",
  "subtopic_name": "Abstraction",
  "mode": "finals",
  "difficulty": "difficult",
  "questions": [
    {
      "question": "What prevents instantiation of abstract classes in C++?",
      "answer": "pure virtual functions",
      "alternatives": [
        "pure virtual"
      ],
      "explanation": "Pure virtual functions make classes abstract.",
      "id": "abst_abst_d_finals_000"
    },
    {
      "question": "What Python metaclass creates abstract base classes?",
      "answer": "ABCMeta",
      "alternatives": [
        "ABC metaclass"
      ],
      "explanation": "ABCMeta enforces abstract method implementation.",
      "id": "abst_abst_d_finals_001"
    },
    {
      "question": "What principle separates concerns through abstraction?",
      "answer": "separation of concerns",
      "alternatives": [
        "SoC"
      ],
      "explanation": "Separation of concerns isolates different aspects.",
      "id": "abst_abst_d_finals_002"
    },
    {
      "question": "What pattern provides simplified interface to complex subsystems?",
      "answer": "facade pattern",
      "alternatives": [
        "facade"
      ],
      "explanation": "Facade pattern creates unified interface.",
      "id": "abst_abst_d_finals_003"
    },
    {
      "question": "What allows runtime selection of algorithms?",
      "answer": "strategy pattern",
      "alternatives": [
        "strategy"
      ],
      "explanation": "Strategy pattern encapsulates interchangeable algorithms.",
      "id": "abst_abst_d_finals_004"
    },
    {
      "question": "What abstraction level defines data structures?",
      "answer": "conceptual level",
      "alternatives": [
        "conceptual abstraction"
      ],
      "explanation": "Conceptual level describes entities and relationships.",
      "id": "abst_abst_d_finals_005"
    },
    {
      "question": "What Java 8 feature adds abstraction flexibility?",
      "answer": "default methods",
      "alternatives": [
        "defender methods"
      ],
      "explanation": "Default methods allow interface evolution.",
      "id": "abst_abst_d_finals_006"
    },
    {
      "question": "What pattern defines interface for creating objects?",
      "answer": "factory pattern",
      "alternatives": [
        "factory"
      ],
      "explanation": "Factory pattern abstracts object creation.",
      "id": "abst_abst_d_finals_007"
    },
    {
      "question": "What principle programs to interfaces not implementations?",
      "answer": "dependency inversion",
      "alternatives": [
        "Dependency Inversion Principle",
        "DIP"
      ],
      "explanation": "Dependency inversion promotes abstraction over concretion.",
      "id": "abst_abst_d_finals_008"
    },
    {
      "question": "What abstraction technique separates interface specification?",
      "answer": "information hiding",
      "alternatives": [
        "data hiding"
      ],
      "explanation": "Information hiding encapsulates implementation details.",
      "id": "abst_abst_d_finals_009"
    }
  ]
}