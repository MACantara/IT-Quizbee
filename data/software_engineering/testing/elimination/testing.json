{
  "subtopic_id": "testing",
  "subtopic_name": "Software Testing",
  "questions": [
    {
      "question": "What is the primary objective of software testing?",
      "options": [
        "To prove that the software has no bugs",
        "To identify defects and ensure software quality",
        "To delay the project timeline",
        "To increase development costs"
      ],
      "correct": 1,
      "explanation": "The primary objective of software testing is to identify defects, verify that the software meets requirements, and ensure overall quality. Testing cannot prove the absence of bugs, but it helps identify and fix them before deployment."
    },
    {
      "question": "Which testing level focuses on testing individual components or modules in isolation?",
      "options": [
        "Integration Testing",
        "System Testing",
        "Unit Testing",
        "Acceptance Testing"
      ],
      "correct": 2,
      "explanation": "Unit Testing focuses on testing individual components, functions, or modules in isolation to verify they work correctly. It's typically performed by developers and is the first level of testing in the software development lifecycle."
    },
    {
      "question": "What is the main difference between black-box and white-box testing?",
      "options": [
        "Black-box is automated, white-box is manual",
        "Black-box tests internal structure, white-box tests functionality",
        "Black-box tests functionality without knowing internals, white-box examines internal code structure",
        "Black-box is for developers, white-box is for testers"
      ],
      "correct": 2,
      "explanation": "Black-box testing focuses on testing functionality and behavior without knowledge of internal code structure, while white-box testing examines the internal logic, code paths, and structure. Both approaches are important for comprehensive testing coverage."
    },
    {
      "question": "In Test-Driven Development (TDD), when are test cases written?",
      "options": [
        "After the code is fully developed",
        "Before writing the actual code",
        "During the maintenance phase",
        "Only for critical features"
      ],
      "correct": 1,
      "explanation": "In Test-Driven Development (TDD), test cases are written before the actual code. The TDD cycle follows: write a failing test, write minimal code to pass the test, then refactor. This approach ensures code meets requirements and is testable from the start."
    },
    {
      "question": "What does test coverage measure in software testing?",
      "options": [
        "The number of testers working on the project",
        "The percentage of code executed by test cases",
        "The time taken to run all tests",
        "The number of bugs found"
      ],
      "correct": 1,
      "explanation": "Test coverage measures the percentage or extent of code that is executed by test cases. It helps identify untested parts of the codebase. Common coverage metrics include statement coverage, branch coverage, and path coverage."
    },
    {
      "question": "Which type of testing verifies that recent code changes haven't adversely affected existing functionality?",
      "options": [
        "Smoke Testing",
        "Regression Testing",
        "Acceptance Testing",
        "Performance Testing"
      ],
      "correct": 1,
      "explanation": "Regression Testing verifies that recent code changes, bug fixes, or new features haven't introduced new defects or broken existing functionality. It's typically automated and run frequently to catch unintended side effects of changes."
    },
    {
      "question": "What is integration testing primarily concerned with?",
      "options": [
        "Testing individual units in isolation",
        "Testing user interfaces",
        "Testing interactions between integrated components or modules",
        "Testing system performance"
      ],
      "correct": 2,
      "explanation": "Integration Testing focuses on testing the interactions and interfaces between integrated components or modules. It verifies that different parts of the system work correctly together after being combined, identifying issues in their interactions."
    },
    {
      "question": "Which testing framework is commonly used for unit testing in Python?",
      "options": [
        "Selenium",
        "JUnit",
        "pytest or unittest",
        "Cucumber"
      ],
      "correct": 2,
      "explanation": "pytest and unittest are the most common unit testing frameworks for Python. pytest is popular for its simplicity and powerful features, while unittest is part of Python's standard library. Both allow developers to write and run automated unit tests."
    },
    {
      "question": "What is the purpose of acceptance testing?",
      "options": [
        "To test code syntax",
        "To verify the system meets business requirements and is ready for delivery",
        "To find all bugs in the system",
        "To test database connections"
      ],
      "correct": 1,
      "explanation": "Acceptance Testing verifies that the system meets business requirements and is ready for delivery to end users. It's often performed by stakeholders or end users (User Acceptance Testing - UAT) to ensure the software satisfies their needs and expectations."
    },
    {
      "question": "What is continuous testing in the context of DevOps?",
      "options": [
        "Testing that never stops even after deployment",
        "Manual testing performed continuously",
        "Automated testing integrated into the CI/CD pipeline for immediate feedback",
        "Testing only critical features continuously"
      ],
      "correct": 2,
      "explanation": "Continuous Testing is the practice of executing automated tests as part of the CI/CD pipeline to obtain immediate feedback on business risks and quality. Tests are automatically triggered with each code change, enabling early defect detection and faster delivery cycles."
    }
  ],
  "mode": "elimination"
}