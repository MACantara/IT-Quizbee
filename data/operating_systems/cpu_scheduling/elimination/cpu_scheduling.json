{
  "subtopic_id": "cpu_scheduling",
  "subtopic_name": "CPU Scheduling",
  "mode": "elimination",
  "questions": [
    {
      "question": "Which scheduling algorithm executes processes in the order they arrive?",
      "options": [
        "Round Robin",
        "First-Come First-Served",
        "Shortest Job First",
        "Priority Scheduling"
      ],
      "correct": 1,
      "explanation": "First-Come First-Served schedules processes in arrival order. It's simple but can cause long waiting times if short processes arrive after long ones.",
      "id": "ope_sys_cpu_sch_elim_000"
    },
    {
      "question": "What scheduling algorithm selects the process with the shortest burst time?",
      "options": [
        "FCFS",
        "Round Robin",
        "Shortest Job First",
        "Priority"
      ],
      "correct": 2,
      "explanation": "Shortest Job First minimizes average waiting time by executing shortest processes first. However, it can cause starvation for long processes.",
      "id": "ope_sys_cpu_sch_elim_001"
    },
    {
      "question": "Which algorithm assigns each process a fixed time quantum?",
      "options": [
        "FCFS",
        "SJF",
        "Round Robin",
        "Priority"
      ],
      "correct": 2,
      "explanation": "Round Robin gives each process a time quantum. If the process doesn't finish, it's moved to the end of the ready queue.",
      "id": "ope_sys_cpu_sch_elim_002"
    },
    {
      "question": "What scheduling approach allows processes to be interrupted?",
      "options": [
        "Non-preemptive",
        "Preemptive",
        "Cooperative",
        "Batch"
      ],
      "correct": 1,
      "explanation": "Preemptive scheduling can interrupt running processes to switch to higher-priority or waiting processes. This prevents CPU monopolization.",
      "id": "ope_sys_cpu_sch_elim_003"
    },
    {
      "question": "Which metric measures the time from submission to completion?",
      "options": [
        "Waiting time",
        "Response time",
        "Turnaround time",
        "CPU utilization"
      ],
      "correct": 2,
      "explanation": "Turnaround time is the total time from arrival to completion, including waiting, execution, and I/O time. It measures overall process time.",
      "id": "ope_sys_cpu_sch_elim_004"
    },
    {
      "question": "What problem occurs when low-priority processes never execute?",
      "options": [
        "Deadlock",
        "Thrashing",
        "Starvation",
        "Fragmentation"
      ],
      "correct": 2,
      "explanation": "Starvation occurs when processes wait indefinitely because higher-priority processes keep arriving. Aging can prevent this by gradually increasing priority.",
      "id": "ope_sys_cpu_sch_elim_005"
    },
    {
      "question": "Which algorithm can lead to the convoy effect?",
      "options": [
        "Round Robin",
        "FCFS",
        "SJF",
        "Priority"
      ],
      "correct": 1,
      "explanation": "FCFS suffers from the convoy effect when short processes wait behind long ones. This increases average waiting time significantly.",
      "id": "ope_sys_cpu_sch_elim_006"
    },
    {
      "question": "What scheduling uses multiple queues with different priorities?",
      "options": [
        "Single queue",
        "Round Robin",
        "Multilevel queue",
        "FCFS"
      ],
      "correct": 2,
      "explanation": "Multilevel queue scheduling assigns processes to different queues based on characteristics. Each queue can have its own scheduling algorithm.",
      "id": "ope_sys_cpu_sch_elim_007"
    },
    {
      "question": "What technique prevents starvation by increasing waiting process priority?",
      "options": [
        "Preemption",
        "Aging",
        "Priority inversion",
        "Time slicing"
      ],
      "correct": 1,
      "explanation": "Aging gradually increases the priority of waiting processes. This ensures long-waiting processes eventually get CPU time despite low initial priority.",
      "id": "ope_sys_cpu_sch_elim_008"
    },
    {
      "question": "Which algorithm is optimal for minimizing average waiting time?",
      "options": [
        "FCFS",
        "Round Robin",
        "Shortest Job First",
        "Priority"
      ],
      "correct": 2,
      "explanation": "Shortest Job First provides optimal average waiting time by always executing the shortest remaining process. However, it requires knowing burst times in advance.",
      "id": "ope_sys_cpu_sch_elim_009"
    }
  ]
}