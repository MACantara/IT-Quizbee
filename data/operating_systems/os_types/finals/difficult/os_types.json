{
  "subtopic_id": "os_types",
  "subtopic_name": "OS Types",
  "mode": "finals",
  "difficulty": "difficult",
  "questions": [
    {
      "question": "A multiprocessor memory architecture where each processor has local memory with non-uniform access times to different memory regions.",
      "answer": "NUMA",
      "alternatives": [
        "Non-Uniform Memory Access",
        "NUMA architecture"
      ],
      "explanation": "NUMA (Non-Uniform Memory Access) systems have memory physically distributed across processors. Each processor has fast access to its local memory but slower access to remote memory, requiring OS awareness for optimal performance through processor-memory affinity.",
      "id": "os_typ_os_typ_d_finals_000"
    },
    {
      "question": "A distributed system architecture where processors have independent memory and communicate via message passing.",
      "answer": "Loosely coupled system",
      "alternatives": [
        "Distributed memory system"
      ],
      "explanation": "Loosely coupled systems have independent processors with separate memories connected by a network. Processors communicate through message passing rather than shared memory, typical of distributed systems and clusters.",
      "id": "os_typ_os_typ_d_finals_001"
    },
    {
      "question": "A multiprocessor architecture where processors share a common memory and communicate through shared memory access.",
      "answer": "Tightly coupled system",
      "alternatives": [
        "Shared memory system"
      ],
      "explanation": "Tightly coupled systems have multiple processors sharing a common physical memory. Processors communicate through shared memory locations, typical of SMP systems where synchronization primitives coordinate access to shared data.",
      "id": "os_typ_os_typ_d_finals_002"
    },
    {
      "question": "Software layer in distributed systems that provides abstractions and common services between applications and the operating system.",
      "answer": "Middleware",
      "alternatives": [
        "Distributed middleware"
      ],
      "explanation": "Middleware abstracts heterogeneity in distributed systems, providing common services like remote procedure calls, message queuing, and transaction management. It simplifies development by hiding network communication complexities and system differences.",
      "id": "os_typ_os_typ_d_finals_003"
    },
    {
      "question": "The architectural advantage of microkernels that makes them particularly suitable for embedded and real-time systems.",
      "answer": "Reliability",
      "alternatives": [
        "Fault isolation",
        "Modularity"
      ],
      "explanation": "Microkernels enhance reliability by running most services in user space. If a service fails, it doesn't crash the kernel. This fault isolation is crucial for embedded and real-time systems where stability and predictability are paramount.",
      "id": "os_typ_os_typ_d_finals_004"
    },
    {
      "question": "Real-time scheduling constraint that specifies the time interval between successive executions of a periodic task.",
      "answer": "Period",
      "alternatives": [
        "Task period",
        "Execution period"
      ],
      "explanation": "In real-time systems, the period defines how often a periodic task must execute. For example, a sensor reading task with a 10ms period must execute every 10 milliseconds to meet its timing requirements.",
      "id": "os_typ_os_typ_d_finals_005"
    },
    {
      "question": "The deadline type in real-time systems representing the maximum time from task release to completion.",
      "answer": "Relative deadline",
      "alternatives": [
        "Deadline constraint"
      ],
      "explanation": "A relative deadline specifies the maximum allowed time from when a task becomes ready until it must complete. It's measured relative to the task's arrival or release time, critical for real-time schedulability analysis.",
      "id": "os_typ_os_typ_d_finals_006"
    },
    {
      "question": "A technique in distributed systems where operations continue despite component failures, ensuring service availability.",
      "answer": "Fault tolerance",
      "alternatives": [
        "Failure resilience"
      ],
      "explanation": "Fault tolerance enables systems to continue operating correctly despite hardware or software failures. Techniques include redundancy, replication, checkpointing, and failover mechanisms to maintain availability and data integrity.",
      "id": "os_typ_os_typ_d_finals_007"
    },
    {
      "question": "The distributed algorithm technique used to achieve agreement among nodes despite failures.",
      "answer": "Consensus protocol",
      "alternatives": [
        "Consensus algorithm",
        "Distributed consensus"
      ],
      "explanation": "Consensus protocols enable distributed nodes to agree on a value despite failures and asynchronous communication. Examples include Paxos and Raft, which are fundamental for maintaining consistency in distributed databases and systems.",
      "id": "os_typ_os_typ_d_finals_008"
    },
    {
      "question": "A distributed file system feature that transparently distributes data across multiple servers for performance and reliability.",
      "answer": "Data replication",
      "alternatives": [
        "File replication",
        "Replication"
      ],
      "explanation": "Data replication stores multiple copies of data across different servers in a distributed file system. It improves availability, fault tolerance, and read performance, but requires consistency protocols to keep replicas synchronized.",
      "id": "os_typ_os_typ_d_finals_009"
    }
  ]
}