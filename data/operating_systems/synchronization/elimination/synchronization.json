{
  "subtopic_id": "synchronization",
  "subtopic_name": "Synchronization",
  "mode": "elimination",
  "questions": [
    {
      "question": "What occurs when concurrent processes access shared data improperly?",
      "options": [
        "Deadlock",
        "Race condition",
        "Starvation",
        "Thrashing"
      ],
      "correct": 1,
      "explanation": "Race conditions happen when execution outcome depends on timing of events. They cause unpredictable behavior with shared resources."
    },
    {
      "question": "What code section accesses shared resources?",
      "options": [
        "Entry section",
        "Critical section",
        "Exit section",
        "Remainder section"
      ],
      "correct": 1,
      "explanation": "Critical sections are code regions accessing shared resources. Only one process should execute its critical section at a time."
    },
    {
      "question": "What synchronization primitive provides mutual exclusion?",
      "options": [
        "Semaphore",
        "Mutex",
        "Monitor",
        "All of the above"
      ],
      "correct": 3,
      "explanation": "Mutexes, semaphores, and monitors all provide mutual exclusion. They ensure only one process accesses critical sections."
    },
    {
      "question": "What semaphore type has binary values?",
      "options": [
        "Counting semaphore",
        "Binary semaphore",
        "Mutex semaphore",
        "General semaphore"
      ],
      "correct": 1,
      "explanation": "Binary semaphores have only 0 and 1 values. They're functionally equivalent to mutexes."
    },
    {
      "question": "What operation decrements a semaphore?",
      "options": [
        "signal",
        "wait",
        "post",
        "unlock"
      ],
      "correct": 1,
      "explanation": "Wait operations decrement semaphores. If the value becomes negative, the process blocks."
    },
    {
      "question": "What classical problem involves multiple threads eating and thinking?",
      "options": [
        "Producer-Consumer",
        "Readers-Writers",
        "Dining Philosophers",
        "Bounded Buffer"
      ],
      "correct": 2,
      "explanation": "Dining Philosophers illustrates deadlock and synchronization challenges. Philosophers alternate between eating and thinking, needing two forks."
    },
    {
      "question": "What high-level synchronization construct provides automatic mutual exclusion?",
      "options": [
        "Semaphore",
        "Mutex",
        "Monitor",
        "Spinlock"
      ],
      "correct": 2,
      "explanation": "Monitors are high-level constructs providing automatic mutual exclusion. They encapsulate shared data and synchronization code."
    },
    {
      "question": "What condition requires processes to eventually enter critical sections?",
      "options": [
        "Mutual exclusion",
        "Progress",
        "Bounded waiting",
        "Atomicity"
      ],
      "correct": 1,
      "explanation": "Progress ensures critical section selection proceeds. Processes outside critical sections can't block others indefinitely."
    },
    {
      "question": "What operation increments a semaphore?",
      "options": [
        "wait",
        "signal",
        "lock",
        "acquire"
      ],
      "correct": 1,
      "explanation": "Signal operations increment semaphores. They may wake blocked processes waiting on the semaphore."
    },
    {
      "question": "What synchronization mechanism repeatedly checks a condition?",
      "options": [
        "Blocking lock",
        "Spinlock",
        "Semaphore",
        "Monitor"
      ],
      "correct": 1,
      "explanation": "Spinlocks busy-wait by repeatedly checking lock availability. They're efficient for short wait times but waste CPU."
    }
  ]
}