{
  "subtopic_id": "solid_principles",
  "subtopic_name": "SOLID Principles",
  "mode": "finals",
  "difficulty": "difficult",
  "questions": [
    {
      "question": "What is a High-Level Module?",
      "answer": "Business logic not depending on details",
      "alternatives": [
        "High level"
      ],
      "explanation": "High-level: abstraction focused. Example: use case. Low-level: database, network. DIP: high depends on abstraction. Importance: architecture."
    },
    {
      "question": "What is a Low-Level Module?",
      "answer": "Implementation details like database",
      "alternatives": [
        "Low level"
      ],
      "explanation": "Low-level: concrete implementation. Example: database driver. High-level: depends on. DIP: both depend on abstraction. Importance: architecture."
    },
    {
      "question": "How do SOLID principles relate to Clean Code?",
      "answer": "SOLID ensures code is clean and maintainable",
      "alternatives": [
        "Clean code"
      ],
      "explanation": "SOLID: guide. Clean code: goal. Relation: SOLID helps achieve. Author: Robert Martin. Purpose: quality. Importance: software craftsmanship."
    },
    {
      "question": "What is the Inversion of Control (IoC) principle?",
      "answer": "Framework controls program flow, not application",
      "alternatives": [
        "IoC"
      ],
      "explanation": "IoC: framework calls your code. Example: callbacks, event handlers. Benefit: flexibility. Related: DIP. Importance: architecture pattern."
    },
    {
      "question": "What is the Hollywood Principle?",
      "answer": "Don't call us, we'll call you",
      "alternatives": [
        "Hollywood principle"
      ],
      "explanation": "Hollywood: framework controls flow. Related: IoC. Benefit: decoupling. Example: frameworks. Importance: control flow principle."
    },
    {
      "question": "What is the Stable Abstraction Principle?",
      "answer": "More stable = more abstract",
      "alternatives": [
        "Stability"
      ],
      "explanation": "Principle: abstract layers stable. Concrete: less stable. Purpose: minimize ripple effects. Importance: package design."
    },
    {
      "question": "What is the Stable Dependencies Principle?",
      "answer": "Depend on more stable packages",
      "alternatives": [
        "Stable deps"
      ],
      "explanation": "Principle: minimize impact. Stable: abstractions, frameworks. Unstable: implementation. Purpose: reduce coupling. Importance: package design."
    },
    {
      "question": "What is Acyclic Dependencies Principle?",
      "answer": "No cyclic dependencies between packages",
      "alternatives": [
        "No cycles"
      ],
      "explanation": "Principle: prevent cycles. Problem: hard to test, deploy. Solution: break with abstraction. Importance: package design."
    },
    {
      "question": "How to apply SOLID to React components?",
      "answer": "SRP: focused, OCP: custom hooks, DIP: props injection",
      "alternatives": [
        "React SOLID"
      ],
      "explanation": "React: component as class. SRP: one job. OCP: composition. DIP: props, context. Purpose: reusable components. Importance: modern app."
    },
    {
      "question": "What is the benefit of SOLID in large teams?",
      "answer": "Reduces conflicts, enables independent work",
      "alternatives": [
        "Team benefit"
      ],
      "explanation": "Benefit: decoupling allows parallel. Team: understand code easily. Maintenance: straightforward. Example: microservices. Importance: team practice."
    }
  ]
}