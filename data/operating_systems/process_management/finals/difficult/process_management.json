{
  "subtopic_id": "process_management",
  "subtopic_name": "Process Management",
  "mode": "finals",
  "difficulty": "difficult",
  "questions": [
    {
      "question": "What threading model maps multiple user threads to one kernel thread?",
      "answer": "Many-to-one",
      "alternatives": [
        "Many-to-one model"
      ],
      "explanation": "Many-to-one models manage threads entirely in user space. If one thread blocks, all threads in the process block since there's only one kernel thread.",
      "id": "pro_man_pro_man_d_finals_000"
    },
    {
      "question": "What threading model creates a kernel thread for each user thread?",
      "answer": "One-to-one",
      "alternatives": [
        "One-to-one model"
      ],
      "explanation": "One-to-one models provide true concurrency by using separate kernel threads. However, creating many threads can burden the system.",
      "id": "pro_man_pro_man_d_finals_001"
    },
    {
      "question": "What allows both user-level and kernel-level thread management?",
      "answer": "Many-to-many",
      "alternatives": [
        "Many-to-many model",
        "Hybrid model"
      ],
      "explanation": "Many-to-many models multiplex user threads onto kernel threads. This combines advantages of both user-level and kernel-level threading.",
      "id": "pro_man_pro_man_d_finals_002"
    },
    {
      "question": "What technique copies process memory only when modifications occur?",
      "answer": "Copy-on-write",
      "alternatives": [
        "COW"
      ],
      "explanation": "Copy-on-write delays memory copying until either process writes to shared pages. This optimizes fork by avoiding unnecessary memory duplication.",
      "id": "pro_man_pro_man_d_finals_003"
    },
    {
      "question": "What Linux system call combines fork and exec functionality?",
      "answer": "vfork",
      "alternatives": [],
      "explanation": "vfork creates a process without copying memory, expecting immediate exec. The parent blocks until the child calls exec or exits.",
      "id": "pro_man_pro_man_d_finals_004"
    },
    {
      "question": "What Linux mechanism creates lightweight processes sharing resources?",
      "answer": "clone",
      "alternatives": [],
      "explanation": "clone provides fine-grained control over what resources are shared between parent and child. It's used to implement threads in Linux.",
      "id": "pro_man_pro_man_d_finals_005"
    },
    {
      "question": "What scheduler component decides which thread runs on a CPU?",
      "answer": "Dispatcher",
      "alternatives": [],
      "explanation": "The dispatcher performs context switching, loading the selected process's state. It's invoked after the scheduler makes scheduling decisions.",
      "id": "pro_man_pro_man_d_finals_006"
    },
    {
      "question": "What prevents race conditions by ensuring mutual exclusion?",
      "answer": "Critical section",
      "alternatives": [
        "Critical region"
      ],
      "explanation": "Critical sections are code regions accessing shared resources. Only one process should execute its critical section at a time.",
      "id": "pro_man_pro_man_d_finals_007"
    },
    {
      "question": "What structure organizes threads belonging to the same process?",
      "answer": "Thread Control Block",
      "alternatives": [
        "TCB"
      ],
      "explanation": "Thread Control Blocks store thread-specific information like stack pointer and registers. Each thread has its own TCB within the process's PCB.",
      "id": "pro_man_pro_man_d_finals_008"
    },
    {
      "question": "What allows a process to create multiple execution contexts?",
      "answer": "Coroutines",
      "alternatives": [],
      "explanation": "Coroutines are subroutines that can suspend and resume execution. They enable cooperative multitasking within a single process.",
      "id": "pro_man_pro_man_d_finals_009"
    }
  ]
}