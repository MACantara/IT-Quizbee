{
  "subtopic_id": "encapsulation",
  "subtopic_name": "Encapsulation",
  "mode": "finals",
  "difficulty": "difficult",
  "questions": [
    {
      "question": "What Python mechanism performs name mangling for private attributes?",
      "answer": "double underscore prefix",
      "alternatives": ["__name", "name mangling", "dunder prefix"],
      "explanation": "Python mangles names with double underscore to _ClassName__attribute."
    },
    {
      "question": "What C++ feature allows granting specific external access to private members?",
      "answer": "friend function",
      "alternatives": ["friend class", "friend"],
      "explanation": "Friend functions can access private and protected members of a class."
    },
    {
      "question": "What design principle suggests using composition over inheritance for encapsulation?",
      "answer": "favor composition",
      "alternatives": ["composition over inheritance"],
      "explanation": "Composition provides better encapsulation than inheritance hierarchies."
    },
    {
      "question": "What pattern encapsulates object creation logic?",
      "answer": "factory pattern",
      "alternatives": ["factory method", "abstract factory"],
      "explanation": "Factory pattern hides instantiation details from clients."
    },
    {
      "question": "What pattern encapsulates algorithms and makes them interchangeable?",
      "answer": "strategy pattern",
      "alternatives": ["strategy"],
      "explanation": "Strategy pattern encapsulates varying behavior in separate classes."
    },
    {
      "question": "What mechanism allows controlled access through interfaces only?",
      "answer": "abstraction barrier",
      "alternatives": ["interface abstraction"],
      "explanation": "Abstraction barriers separate interface from implementation."
    },
    {
      "question": "What Java modifier restricts subclass method overriding?",
      "answer": "final",
      "alternatives": ["Final"],
      "explanation": "Final methods cannot be overridden to protect behavior."
    },
    {
      "question": "What concept describes exposing only necessary operations?",
      "answer": "interface segregation",
      "alternatives": ["minimal interface", "lean interface"],
      "explanation": "Interfaces should be specific and not expose unnecessary methods."
    },
    {
      "question": "What technique validates state consistency in setters?",
      "answer": "invariant checking",
      "alternatives": ["invariants", "class invariants"],
      "explanation": "Invariant checking ensures object state remains valid after changes."
    },
    {
      "question": "What principle states each module should have limited knowledge of others?",
      "answer": "Law of Demeter",
      "alternatives": ["principle of least knowledge", "LoD"],
      "explanation": "Law of Demeter promotes loose coupling through minimal interaction."
    }
  ]
}