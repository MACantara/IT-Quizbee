{
  "subtopic_id": "encapsulation",
  "subtopic_name": "Encapsulation",
  "mode": "finals",
  "difficulty": "average",
  "questions": [
    {
      "question": "What is the difference between encapsulation and abstraction?",
      "answer": "Encapsulation hides state, abstraction hides complexity",
      "alternatives": [
        "Distinction"
      ],
      "explanation": "Encapsulation: data hiding via access control. Abstraction: complexity hiding via interface. Focus: encapsulation on data, abstraction on behavior. Related: both achieve information hiding. Importance: distinction."
    },
    {
      "question": "What is the Single Responsibility Principle?",
      "answer": "Class should have one reason to change",
      "alternatives": [
        "SRP"
      ],
      "explanation": "SRP: one responsibility. Purpose: maintainability. Benefit: easier changes. Example: User class - no DB logic. Importance: SOLID principle."
    },
    {
      "question": "What is a class invariant?",
      "answer": "Condition always true for class",
      "alternatives": [
        "Invariant"
      ],
      "explanation": "Invariant: maintained by methods. Example: balance >= 0. Purpose: correctness guarantee. Enforcement: constructors, methods. Importance: correctness."
    },
    {
      "question": "What is immutability?",
      "answer": "Object cannot change after creation",
      "alternatives": [
        "Unchanging object"
      ],
      "explanation": "Immutable: read-only after init. Benefits: thread safety, caching. Drawback: create new for changes. Example: String in Java. Importance: concurrency."
    },
    {
      "question": "What is a final class?",
      "answer": "Cannot be extended",
      "alternatives": [
        "Sealed class"
      ],
      "explanation": "Final: prevents inheritance. Purpose: immutability guarantee, security. Example: String in Java. Language: Java, C++. Importance: design control."
    },
    {
      "question": "What is a final method?",
      "answer": "Cannot be overridden",
      "alternatives": [
        "Sealed method"
      ],
      "explanation": "Final: prevents override. Purpose: preserve behavior. Language: Java. Benefit: prevent mistakes. Importance: design control."
    },
    {
      "question": "What is a final field?",
      "answer": "Cannot be changed after initialization",
      "alternatives": [
        "Constant field"
      ],
      "explanation": "Final: read-only after init. Purpose: immutability, thread safety. Must: initialize at declaration or constructor. Importance: data safety."
    },
    {
      "question": "What is defensive copying?",
      "answer": "Copy mutable objects to prevent external changes",
      "alternatives": [
        "Copy defense"
      ],
      "explanation": "Copying: create new instance. Purpose: protect internal state. Benefit: prevent aliasing bugs. Example: return new ArrayList(list). Importance: immutability."
    },
    {
      "question": "What is shallow copy?",
      "answer": "Copy only references, not objects",
      "alternatives": [
        "Shallow clone"
      ],
      "explanation": "Shallow: references same objects. Problem: modifications affect original. Usage: rarely desired. Benefit: fast. Importance: copy semantics."
    },
    {
      "question": "What is deep copy?",
      "answer": "Copy object and all nested objects",
      "alternatives": [
        "Deep clone"
      ],
      "explanation": "Deep: recursively copy. Benefit: completely independent. Drawback: expensive. Usage: when needed. Importance: copy semantics."
    }
  ]
}