{
  "subtopic_id": "relational_model",
  "subtopic_name": "Relational Model",
  "mode": "finals",
  "difficulty": "average",
  "questions": [
    {
      "question": "What removal of duplicate data improves storage efficiency?",
      "answer": "Denormalization",
      "alternatives": [
        "Optimization technique"
      ],
      "explanation": "Denormalization intentionally reintroduces redundancy to relations for query performance. Reverses normalization by combining tables to reduce joins. Benefits: faster queries, fewer disk I/O. Drawbacks: more storage, update complexity, consistency risk. Used when query performance critical. Requires careful consideration and monitoring. Common in data warehousing."
    },
    {
      "question": "What second normal form requires?",
      "answer": "No partial dependencies",
      "alternatives": [
        "2NF requirement"
      ],
      "explanation": "Second Normal Form (2NF) requires 1NF plus no non-key attributes depend on part of composite primary key (partial dependency). Ensures each non-key attribute depends on entire primary key. Example: in StudentCourse(StudentID, CourseID, Grade, CourseName), CourseName depends on CourseID only, not both. Eliminates 2NF violations by decomposing relations."
    },
    {
      "question": "What third normal form eliminates?",
      "answer": "Transitive dependencies",
      "alternatives": [
        "3NF goal"
      ],
      "explanation": "Third Normal Form (3NF) requires 2NF plus no non-key attributes depend on other non-key attributes (transitive dependency). Example: if StudentDorm(StudentID, DormID, DormLocation) and DormLocation depends on DormID (non-key), this violates 3NF. 3NF most common form for business databases, balancing normalization and performance."
    },
    {
      "question": "What form goes beyond 3NF for stricter constraints?",
      "answer": "Boyce-Codd Normal Form",
      "alternatives": [
        "BCNF"
      ],
      "explanation": "Boyce-Codd Normal Form (BCNF) requires 3NF plus every determinant (attribute determining another) is candidate key. Stricter than 3NF; table in BCNF is in 3NF but not vice versa. Eliminates all anomalies related to functional dependencies. Some relations can't achieve BCNF without losing information; 3NF is acceptable alternative."
    },
    {
      "question": "What relationship can one tuple have with many tuples in another relation?",
      "answer": "One-to-many",
      "alternatives": [
        "1:N relationship"
      ],
      "explanation": "One-to-many (1:N) relationship allows one tuple in relation A to relate to many tuples in relation B. Most common relationship type. Example: one Department has many Employees. Implemented via foreign key in 'many' side table. Decomposed in relational model to separate relations connected by foreign key."
    },
    {
      "question": "What relationship requires decomposition into separate table?",
      "answer": "Many-to-many",
      "alternatives": [
        "M:N relationship"
      ],
      "explanation": "Many-to-many (M:N) relationship allows many tuples in relation A to relate to many in relation B. Cannot directly implement; requires junction/bridge table. Example: many Students take many Courses; create StudentCourse table with StudentID and CourseID. Junction table contains foreign keys from both relations, possibly additional attributes."
    },
    {
      "question": "What describes properties functional dependency must satisfy?",
      "answer": "Functional dependency",
      "alternatives": [
        "FD"
      ],
      "explanation": "Functional dependency (FD) exists when values of one attribute determine values of another (A  B). Example: StudentID  Name (each StudentID has exactly one Name). FDs identify candidate keys and guide normalization. Trivial FD: B  A. Non-trivial: B  A. Full FD: cannot remove attributes from determinant. Partial: can remove attributes."
    },
    {
      "question": "What describes a candidate key in BCNF context?",
      "answer": "Determinant",
      "alternatives": [
        "Candidate key"
      ],
      "explanation": "Determinant is attribute (or set) whose values uniquely determine values of other attributes. In functional dependency A  B, A is determinant of B. Every determinant should be candidate key for BCNF. Example: StudentID determines student name; StudentID is determinant. Identifying determinants essential for normalization analysis."
    },
    {
      "question": "What represents multivalued dependency in relations?",
      "answer": "Fourth normal form",
      "alternatives": [
        "4NF"
      ],
      "explanation": "Fourth Normal Form (4NF) handles multivalued dependencies (one attribute determines multiple independent attributes). Example: if Author and Subject independent of each other for same Book, creates multivalued dependency. 4NF requires BCNF plus no non-trivial multivalued dependencies. Rare in practice; most projects use 3NF or BCNF."
    },
    {
      "question": "What determines if decomposition is lossless?",
      "answer": "Lossless decomposition",
      "alternatives": [
        "Join property"
      ],
      "explanation": "Lossless decomposition (also join property) ensures joining decomposed relations recovers original data without spurious tuples. Critical for valid normalization. Lossy decomposition loses information during join. To ensure lossless: decomposed relations must preserve functional dependencies. Chase algorithm verifies lossless property mathematically."
    }
  ]
}