{
  "subtopic_id": "software_design",
  "subtopic_name": "Software Design",
  "mode": "finals",
  "difficulty": "difficult",
  "questions": [
    {
      "question": "The SOLID principle stating clients shouldn't depend on interfaces they don't use.",
      "answer": "Interface Segregation Principle",
      "alternatives": [
        "ISP"
      ],
      "explanation": "ISP states that clients should not be forced to depend on interfaces they don't use; split interfaces appropriately.",
      "id": "sof_des_sof_des_d_finals_000"
    },
    {
      "question": "The SOLID principle advocating dependency on abstractions rather than concrete implementations.",
      "answer": "Dependency Inversion Principle",
      "alternatives": [
        "DIP"
      ],
      "explanation": "DIP states high-level modules shouldn't depend on low-level modules; both should depend on abstractions.",
      "id": "sof_des_sof_des_d_finals_001"
    },
    {
      "question": "The architectural pattern where components communicate through a central mediator.",
      "answer": "Mediator Pattern",
      "alternatives": [
        "Mediator"
      ],
      "explanation": "Mediator pattern centralizes complex communications and control logic between related objects.",
      "id": "sof_des_sof_des_d_finals_002"
    },
    {
      "question": "The design pattern that provides access to elements of a collection sequentially.",
      "answer": "Iterator",
      "alternatives": [
        "Iterator Pattern"
      ],
      "explanation": "Iterator pattern provides a way to access elements of a collection sequentially without exposing its structure.",
      "id": "sof_des_sof_des_d_finals_003"
    },
    {
      "question": "The design pattern that captures and externalizes object state for later restoration.",
      "answer": "Memento",
      "alternatives": [
        "Memento Pattern"
      ],
      "explanation": "Memento pattern captures an object's internal state to enable undo or rollback operations.",
      "id": "sof_des_sof_des_d_finals_004"
    },
    {
      "question": "The architectural style with asynchronous message passing between components.",
      "answer": "Event-Driven Architecture",
      "alternatives": [
        "EDA",
        "Message-Driven"
      ],
      "explanation": "Event-driven architecture uses events to trigger and communicate between decoupled services.",
      "id": "sof_des_sof_des_d_finals_005"
    },
    {
      "question": "The pattern that composes objects into tree structures for part-whole hierarchies.",
      "answer": "Composite",
      "alternatives": [
        "Composite Pattern"
      ],
      "explanation": "Composite pattern lets clients treat individual objects and compositions uniformly through tree structures.",
      "id": "sof_des_sof_des_d_finals_006"
    },
    {
      "question": "The design pattern that provides a way to access object elements without exposing structure.",
      "answer": "Visitor",
      "alternatives": [
        "Visitor Pattern"
      ],
      "explanation": "Visitor pattern separates algorithms from the objects they operate on by adding operations externally.",
      "id": "sof_des_sof_des_d_finals_007"
    },
    {
      "question": "The architectural pattern separating read and write operations for scalability.",
      "answer": "CQRS",
      "alternatives": [
        "Command Query Responsibility Segregation"
      ],
      "explanation": "CQRS separates read and write models to optimize performance, scalability, and security independently.",
      "id": "sof_des_sof_des_d_finals_008"
    },
    {
      "question": "The principle stating prefer object composition over class inheritance.",
      "answer": "Composition Over Inheritance",
      "alternatives": [
        "Favor Composition"
      ],
      "explanation": "This principle advocates using object composition for flexibility rather than rigid inheritance hierarchies.",
      "id": "sof_des_sof_des_d_finals_009"
    }
  ]
}