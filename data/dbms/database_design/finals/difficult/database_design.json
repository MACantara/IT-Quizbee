{
  "subtopic_id": "database_design",
  "subtopic_name": "Database Design",
  "mode": "finals",
  "difficulty": "difficult",
  "questions": [
    {
      "question": "What advanced normalization addresses anomalies?",
      "answer": "Decomposition algorithm",
      "alternatives": [
        "Lossless decomposition"
      ],
      "explanation": "Decomposition algorithm systematically converts to higher normal forms. Algorithm: identify violations, decompose tables, verify lossless, preserve dependencies. Mathematical: FD closure, attribute closure, chase test. Complex: requires theoretical knowledge. Tools: automated analysis preferred."
    },
    {
      "question": "What design pattern handles versions?",
      "answer": "Temporal tables",
      "alternatives": [
        "Versioned entities"
      ],
      "explanation": "Temporal tables: maintain history of changes (when data changed, who changed, what changed). Techniques: audit tables, versioned rows, time-dimension. Benefits: compliance, analysis, rollback. Complexity: queries more complex (filter by date). SQL Server/PostgreSQL support temporal features."
    },
    {
      "question": "What metric measures data volume handling?",
      "answer": "Scalability analysis",
      "alternatives": [
        "Capacity planning"
      ],
      "explanation": "Scalability analysis: estimate database size growth, query volume growth. Model: storage (bytes/year), queries/sec increase. Identify limits: storage, I/O capacity, CPU. Plan: sharding, archiving, caching. Prevents surprises: design for growth. Continuous monitoring: adjust as needed."
    },
    {
      "question": "What addresses concurrent access conflicts?",
      "answer": "Conflict detection",
      "alternatives": [
        "Concurrency control"
      ],
      "explanation": "Conflict detection: identify when concurrent access causes issues (lost updates, inconsistency). Techniques: optimistic (detect at commit), pessimistic (lock before). Identify: audit logs, application traces. Solutions: locking strategy, serialization, eventual consistency. Design choice: safety vs. performance."
    },
    {
      "question": "What design ensures audit and compliance?",
      "answer": "Audit trail",
      "alternatives": [
        "Audit logging"
      ],
      "explanation": "Audit trail: log all modifications (who, what, when, why). Enables: compliance (GDPR, HIPAA), investigation, rollback support. Challenges: performance (audit logging overhead), storage (audit data grows). Design: separate audit tables, triggers, application logging. Critical for regulated industries."
    },
    {
      "question": "What handles high-concurrency scenarios?",
      "answer": "Sharding strategy",
      "alternatives": [
        "Horizontal scaling"
      ],
      "explanation": "Sharding strategy: distribute data across servers for scale. Design: choose shard key (determines distribution), implement shard function. Challenges: hotspots, queries across shards, transactions. Key design: pick key with even distribution, common in queries. Addresses scalability limits."
    },
    {
      "question": "What ensures disaster recovery?",
      "answer": "Redundancy strategy",
      "alternatives": [
        "Backup and recovery"
      ],
      "explanation": "Redundancy strategy: replicate data across locations for recovery. Techniques: primary-backup replication, multi-region, active-active. Recovery time objective (RTO): how fast to recover. Recovery point objective (RPO): how much loss acceptable. Design: balance cost/recovery requirements."
    },
    {
      "question": "What addresses security at database level?",
      "answer": "Row-level security",
      "alternatives": [
        "Fine-grained access"
      ],
      "explanation": "Row-level security: users see different data based on credentials. Example: Sales rep sees only their region. Implemented: database views, policies, application logic. Benefits: strong enforcement, transparency. Challenges: query complexity, performance. Increasingly supported: SQL Server, PostgreSQL."
    },
    {
      "question": "What handles complex analytical queries?",
      "answer": "Aggregate table strategy",
      "alternatives": [
        "Pre-aggregation"
      ],
      "explanation": "Aggregate table strategy: pre-calculate common aggregations. Example: sales by month, by region. Benefits: fast queries (pre-calculated), simple analytics. Drawbacks: storage, maintenance (refresh), staleness. Used: analytics, dashboards. Tools: materialized views, ETL processes."
    },
    {
      "question": "What design principle guides schema evolution?",
      "answer": "Schema versioning",
      "alternatives": [
        "Schema migration"
      ],
      "explanation": "Schema versioning: manage database schema changes (add column, rename table). Challenges: backward compatibility, online migration (avoid downtime), data consistency. Strategies: deprecate old schema, migrate data gradually, support multiple versions temporarily. Critical for: live systems, zero-downtime deployments."
    }
  ]
}