{
  "subtopic_id": "solid_principles",
  "subtopic_name": "SOLID Principles",
  "mode": "finals",
  "difficulty": "difficult",
  "questions": [
    {
      "question": "What does SOLID stand for?",
      "answer": "Single Responsibility, Open-Closed, Liskov Substitution, Interface Segregation, Dependency Inversion",
      "alternatives": [],
      "explanation": "SOLID is an acronym for five design principles: Single Responsibility, Open-Closed, Liskov Substitution, Interface Segregation, and Dependency Inversion."
    },
    {
      "question": "What is the Single Responsibility Principle (SRP)?",
      "answer": "A class should have only one reason to change",
      "alternatives": [],
      "explanation": "The Single Responsibility Principle states that a class should have only one reason to change, meaning it should have only one job or responsibility."
    },
    {
      "question": "What is the Open-Closed Principle (OCP)?",
      "answer": "Software entities should be open for extension but closed for modification",
      "alternatives": [],
      "explanation": "The Open-Closed Principle states that software entities should be open for extension (adding new functionality) but closed for modification (existing code should not be changed)."
    },
    {
      "question": "What is the Liskov Substitution Principle (LSP)?",
      "answer": "Objects of a superclass should be replaceable with objects of its subclasses without breaking the application",
      "alternatives": [],
      "explanation": "The Liskov Substitution Principle states that objects of a superclass should be replaceable with objects of its subclasses without affecting the correctness of the program."
    },
    {
      "question": "What is the Interface Segregation Principle (ISP)?",
      "answer": "Clients should not be forced to depend on interfaces they don't use",
      "alternatives": [],
      "explanation": "The Interface Segregation Principle states that no client should be forced to depend on methods it doesn't use. It's better to have many small, specific interfaces than one large, general interface."
    },
    {
      "question": "What is the Dependency Inversion Principle (DIP)?",
      "answer": "High-level modules should not depend on low-level modules; both should depend on abstractions",
      "alternatives": [],
      "explanation": "The Dependency Inversion Principle states that high-level modules should not depend on low-level modules. Both should depend on abstractions, and abstractions should not depend on details."
    },
    {
      "question": "Which SOLID principle does this violate: A class that handles both database operations and email sending?",
      "answer": "Single Responsibility Principle",
      "alternatives": [],
      "explanation": "This violates the Single Responsibility Principle because the class has two reasons to change: database logic changes or email logic changes. Each responsibility should be in a separate class."
    },
    {
      "question": "How does the Open-Closed Principle promote code maintainability?",
      "answer": "By allowing new features through extension rather than modifying existing code",
      "alternatives": [],
      "explanation": "OCP promotes maintainability by encouraging extension through inheritance, interfaces, or composition rather than modifying existing, tested code, reducing the risk of introducing bugs."
    },
    {
      "question": "What technique supports the Dependency Inversion Principle?",
      "answer": "Dependency Injection",
      "alternatives": [],
      "explanation": "Dependency Injection is a key technique for implementing DIP. It involves passing dependencies (usually as interfaces) to a class rather than having the class create them directly."
    },
    {
      "question": "Why is following SOLID principles important?",
      "answer": "Makes code more maintainable, testable, and flexible",
      "alternatives": [],
      "explanation": "SOLID principles lead to code that is more maintainable (easier to modify), testable (easier to unit test), and flexible (easier to extend), resulting in better software design."
    }
  ]
}