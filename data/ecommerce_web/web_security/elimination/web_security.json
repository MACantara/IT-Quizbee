{
  "subtopic_id": "web_security",
  "subtopic_name": "Web Security",
  "questions": [
    {
      "question": "What is HTTPS and why is it important for websites?",
      "options": [
        "Hyper Text Transfer Protocol Secure - encrypts data transmission between browser and server, protecting user data",
        "High Transfer Protocol System",
        "Hyperlink Text Protection System",
        "HTTP Switching protocol"
      ],
      "correct": 0,
      "explanation": "HTTPS (HyperText Transfer Protocol Secure) is the secure version of HTTP, using SSL/TLS encryption to protect data transmitted between user's browser and website server, preventing interception and tampering. How it works: (1) Browser requests secure connection, (2) Server sends SSL/TLS certificate, (3) Browser verifies certificate authenticity, (4) Encrypted connection established (SSL/TLS handshake), (5) Data exchanged encrypted. Visual indicators: padlock icon in address bar, 'https://' prefix, 'Secure' or 'Not Secure' label. Why essential: (1) Data protection: encrypts sensitive info (passwords, credit cards, personal data), (2) Authentication: verifies website identity (prevents phishing), (3) Trust: users trust secure sites more, (4) SEO: Google ranking factor (since 2014), (5) Browser warnings: Chrome/Firefox show 'Not Secure' for HTTP sites, (6) Compliance: required for PCI DSS (payment processing), GDPR, (7) Prevents MITM attacks: man-in-the-middle interception. SSL/TLS certificates: from Certificate Authorities (Let's Encrypt free, Comodo, DigiCert). HTTP vs. HTTPS: port 80 vs. 443, unencrypted vs. encrypted. Modern standard: all websites should use HTTPS, especially e-commerce, login pages, any form input."
    },
    {
      "question": "What is Cross-Site Scripting (XSS)?",
      "options": [
        "Switching between websites",
        "A security vulnerability allowing attackers to inject malicious scripts into web pages viewed by other users",
        "Cross-platform development",
        "A legitimate scripting technique"
      ],
      "correct": 1,
      "explanation": "XSS (Cross-Site Scripting) is a web security vulnerability allowing attackers to inject malicious JavaScript into web pages, which then executes in victims' browsers, potentially stealing data or hijacking sessions. How XSS works: (1) Attacker finds input field without validation (comments, search, forms), (2) Injects malicious script (e.g., <script>steal_cookies()</script>), (3) Script stored/reflected on page, (4) Victim visits page, (5) Malicious script executes in victim's browser, (6) Attacker steals cookies, session tokens, or performs actions as victim. Types: (1) Stored XSS: malicious script permanently stored on server (database, comments), most dangerous, (2) Reflected XSS: script in URL/input immediately reflected (phishing links), (3) DOM-based XSS: vulnerability in client-side JavaScript. Impact: session hijacking (steal cookies/tokens), credential theft (fake login forms), defacement, malware distribution, keylogging. Prevention: (1) Input validation: sanitize all user input, (2) Output encoding: escape special characters (<, >, &, \", '), (3) Content Security Policy (CSP): restrict script sources, (4) HttpOnly cookies: prevent JavaScript access, (5) Framework protection: React, Angular auto-escape. Testing: try injecting <script>alert('XSS')</script>. Part of OWASP Top 10. Critical for any site with user input."
    },
    {
      "question": "What is SQL Injection?",
      "options": [
        "Injecting SQL code into databases",
        "A vulnerability allowing attackers to manipulate database queries by injecting malicious SQL code through input fields",
        "A database update technique",
        "Adding SQL to websites"
      ],
      "correct": 1,
      "explanation": "SQL Injection is a critical web security vulnerability allowing attackers to interfere with database queries by inserting malicious SQL code through user input fields, potentially accessing, modifying, or deleting data. How it works: vulnerable code concatenates user input into SQL query: `query = \"SELECT * FROM users WHERE username = '\" + userInput + \"'\";` Attacker enters: `admin' OR '1'='1' --` resulting in: `SELECT * FROM users WHERE username = 'admin' OR '1'='1' --'` which returns all users (always true). Attack examples: (1) Authentication bypass: login without password, (2) Data theft: retrieve sensitive data (SELECT * FROM credit_cards), (3) Data modification: UPDATE/DELETE records, (4) Command execution: some databases allow OS commands. Impact: complete database compromise, data breaches, data loss, unauthorized access, system takeover. Prevention: (1) Parameterized queries (prepared statements): separate SQL logic from data, `query = \"SELECT * FROM users WHERE username = ?\"; params = [userInput]`, (2) Input validation: whitelist allowed characters, (3) Escape user input: special characters, (4) Least privilege: database user limited permissions, (5) WAF (Web Application Firewall): detect/block attacks, (6) ORM frameworks: Sequelize, SQLAlchemy (built-in protection). Testing: try input `' OR 1=1--`. OWASP Top 10 #1. Essential protection for all database-driven applications."
    },
    {
      "question": "What is Cross-Site Request Forgery (CSRF)?",
      "options": [
        "Cross-site data sharing",
        "An attack forcing users to execute unwanted actions on authenticated websites by tricking their browser",
        "Forging website certificates",
        "Cross-platform requests"
      ],
      "correct": 1,
      "explanation": "CSRF (Cross-Site Request Forgery, pronounced 'sea-surf') is an attack forcing authenticated users to execute unwanted actions on web applications where they're currently logged in, exploiting the browser's automatic sending of authentication cookies. How CSRF works: (1) Victim logged into legitimate site (bank.com), browser stores session cookie, (2) Victim visits malicious site (attacker.com) while still logged in, (3) Malicious site contains hidden request to legitimate site (e.g., <img src='https://bank.com/transfer?amount=1000&to=attacker'>), (4) Browser automatically includes session cookie with request, (5) Legitimate site processes request thinking it's from user, (6) Attacker successfully executes unauthorized action. Attack examples: transfer money, change email/password, make purchases, post content, modify settings. Requirements: (1) User authenticated to target site, (2) Browser automatically sends credentials (cookies), (3) No CSRF protection on target site. Prevention: (1) CSRF tokens: unique, unpredictable token per session/request, included in forms/requests, server validates, (2) SameSite cookie attribute: prevents cookies sent with cross-site requests (SameSite=Strict/Lax), (3) Check Referer/Origin headers: verify request source, (4) Re-authentication: for sensitive actions (confirm password), (5) Custom headers: API requests with custom header (AJAX). Modern frameworks: built-in CSRF protection (Django, Rails, Express with csurf). OWASP Top 10. Critical for authenticated actions."
    },
    {
      "question": "What is the difference between authentication and authorization?",
      "options": [
        "They are the same thing",
        "Authentication verifies identity (who you are); authorization determines access permissions (what you can do)",
        "Authentication is for websites, authorization for APIs",
        "Authorization comes before authentication"
      ],
      "correct": 1,
      "explanation": "Authentication and authorization are distinct security concepts working together to secure applications. Authentication: verifying identity - proving you are who you claim to be. Process: (1) User provides credentials (username/password, biometrics, token), (2) System verifies credentials against database, (3) If valid, user authenticated. Methods: (1) Password-based: traditional, (2) Multi-factor (MFA): password + code/biometric, (3) Token-based: JWT, OAuth tokens, (4) Biometric: fingerprint, face ID, (5) SSO (Single Sign-On): one login for multiple systems. Question: WHO are you? Authorization: determining access permissions - what authenticated user can do/access. Process: (1) User already authenticated, (2) User requests resource/action, (3) System checks permissions/roles, (4) Grants or denies access. Methods: (1) Role-Based Access Control (RBAC): permissions by role (admin, user, guest), (2) Access Control Lists (ACL): specific permissions per user, (3) Attribute-Based Access Control (ABAC): dynamic rules. Question: WHAT can you do? Example: Airport security checks ID (authentication), boarding pass determines which plane you can board (authorization). Order: always authenticate first, then authorize. Both essential for comprehensive security. Implementation: authentication establishes identity (session/token), authorization checks permissions before allowing actions."
    },
    {
      "question": "What is JSON Web Token (JWT)?",
      "options": [
        "A JSON database",
        "A compact, self-contained token format for securely transmitting information and authentication between parties",
        "A web tool",
        "JavaScript Web Toolkit"
      ],
      "correct": 1,
      "explanation": "JWT (JSON Web Token, pronounced 'jot') is an open standard (RFC 7519) for securely transmitting information between parties as a JSON object, commonly used for authentication and information exchange in modern web applications. Structure: three parts separated by dots (xxxxx.yyyyy.zzzzz): (1) Header: algorithm and token type `{\"alg\": \"HS256\", \"typ\": \"JWT\"}`, (2) Payload: claims (data) - user info, expiration `{\"sub\": \"user123\", \"name\": \"John\", \"exp\": 1516239022}`, (3) Signature: verify integrity `HMACSHA256(base64(header) + \".\" + base64(payload), secret)`. How JWT authentication works: (1) User logs in with credentials, (2) Server verifies, creates JWT with user info, (3) Server signs JWT and sends to client, (4) Client stores JWT (localStorage, cookie), (5) Client includes JWT in Authorization header for requests: `Authorization: Bearer <token>`, (6) Server verifies signature and extracts user info, (7) Server processes request if valid. Benefits: (1) Stateless: no server-side session storage, (2) Scalable: works across multiple servers, (3) Cross-domain: CORS-friendly, (4) Self-contained: carries user info, (5) Mobile-friendly. Security: HTTPS required, short expiration, refresh tokens, secure storage, validate signature. Use cases: authentication, API authorization, information exchange. Popular libraries: jsonwebtoken (Node.js), PyJWT (Python)."
    },
    {
      "question": "What is CORS (Cross-Origin Resource Sharing)?",
      "options": [
        "Core Resource System",
        "A security mechanism allowing or restricting web pages to request resources from different domains",
        "Cross-platform Operations",
        "Content Organization System"
      ],
      "correct": 1,
      "explanation": "CORS (Cross-Origin Resource Sharing) is a browser security mechanism controlling how web pages from one origin (domain) can request resources from different origins, relaxing the Same-Origin Policy when needed while maintaining security. Same-Origin Policy: browsers restrict cross-origin requests for security (prevents malicious sites from accessing your data on other sites). Same origin: matching protocol, domain, port. Example: https://example.com:443/page can only request from same origin. CORS enables controlled exceptions: server explicitly allows specific cross-origin requests. How CORS works: (1) Browser makes request to different origin, (2) Browser automatically adds Origin header: `Origin: https://example.com`, (3) Server responds with CORS headers: `Access-Control-Allow-Origin: https://example.com` or `*` (all origins), (4) Browser checks response headers, (5) If allowed, browser permits JavaScript to access response, (6) If not allowed, browser blocks access (CORS error). Preflight requests: for complex requests (PUT, DELETE, custom headers), browser sends OPTIONS request first to check permissions. CORS headers: Access-Control-Allow-Origin (allowed origins), Access-Control-Allow-Methods (allowed HTTP methods), Access-Control-Allow-Headers (allowed headers), Access-Control-Allow-Credentials (cookies allowed). Server configuration: backend sets headers (Express: cors middleware, Django: django-cors-headers). Common issue: CORS errors when frontend/backend on different domains - solve by configuring server CORS policy."
    },
    {
      "question": "What is password hashing and why is it important?",
      "options": [
        "Shortening passwords",
        "Converting passwords into fixed-length, irreversible strings using cryptographic functions, protecting stored passwords",
        "Encrypting passwords reversibly",
        "Hiding passwords with hashtags"
      ],
      "correct": 1,
      "explanation": "Password hashing transforms passwords into fixed-length, irreversible strings using cryptographic hash functions, ensuring even if databases are breached, original passwords remain protected. Hash function characteristics: (1) One-way: impossible to reverse (unlike encryption), (2) Deterministic: same input always produces same hash, (3) Fixed-length: any input length produces same output length, (4) Avalanche effect: tiny input change drastically changes hash, (5) Fast to compute (for verification). Why hash passwords: (1) Database breaches: attackers can't read original passwords, (2) Protect users: many reuse passwords across sites, (3) Insider threats: admins can't see passwords, (4) Compliance: required by many regulations. Secure hashing algorithms: (1) bcrypt: designed for passwords, adaptive (configurable rounds), built-in salt, industry standard, (2) Argon2: modern, memory-hard, resistant to GPU/ASIC attacks, (3) PBKDF2: standard, configurable iterations. AVOID: MD5, SHA-1 (too fast, vulnerable), plain SHA-256 without salt (rainbow table attacks). Salting: add random data before hashing, unique per user, prevents rainbow table attacks. Login process: (1) User enters password, (2) Hash entered password with stored salt, (3) Compare with stored hash, (4) Match = authenticated. Never store plaintext passwords. Hashing is irreversible, encryption is reversible."
    },
    {
      "question": "What is Content Security Policy (CSP)?",
      "options": [
        "Content creation policy",
        "A security header restricting sources from which browsers can load resources, mitigating XSS and injection attacks",
        "Copyright protection",
        "Content scheduling policy"
      ],
      "correct": 1,
      "explanation": "CSP (Content Security Policy) is a security standard implemented as HTTP response header that restricts which sources browsers can load resources from (scripts, styles, images), significantly reducing XSS attack surface by preventing execution of unauthorized code. How CSP works: server sends CSP header with directives specifying allowed sources: `Content-Security-Policy: default-src 'self'; script-src 'self' https://trusted.com; img-src *; style-src 'self' 'unsafe-inline'` Browser enforces policy: only loads resources matching directives, blocks violations, optionally reports violations. Key directives: (1) default-src: fallback for other directives, (2) script-src: JavaScript sources, (3) style-src: CSS sources, (4) img-src: image sources, (5) font-src: font sources, (6) connect-src: AJAX, WebSocket sources, (7) frame-src: iframe sources, (8) media-src: audio/video sources. Values: (1) 'self': same origin only, (2) 'none': block all, (3) 'unsafe-inline': allow inline scripts/styles (avoid), (4) 'unsafe-eval': allow eval() (avoid), (5) https://example.com: specific domain, (6) *: allow all (too permissive). Benefits: (1) XSS mitigation: blocks inline scripts and unauthorized sources, (2) Clickjacking protection: frame-ancestors directive, (3) Injection prevention: mixed content blocking. Report-only mode: test without enforcing `Content-Security-Policy-Report-Only`. Violation reports: report-uri/report-to directives send violation logs. Implementation: start strict, gradually relax if needed. Modern security essential."
    },
    {
      "question": "What is the OWASP Top 10?",
      "options": [
        "Top 10 web frameworks",
        "A list of the 10 most critical web application security risks identified by Open Web Application Security Project",
        "Top 10 websites",
        "Top 10 security companies"
      ],
      "correct": 1,
      "explanation": "OWASP Top 10 is a regularly updated list documenting the most critical web application security risks, published by OWASP (Open Web Application Security Project), serving as a standard awareness document for developers and security professionals. OWASP Top 10 (2021): (1) A01: Broken Access Control: unauthorized access to functionality/data (IDOR, privilege escalation), (2) A02: Cryptographic Failures: sensitive data exposure (weak encryption, missing SSL), (3) A03: Injection: SQL, NoSQL, OS command, LDAP injection, (4) A04: Insecure Design: missing security controls in design phase, threat modeling, (5) A05: Security Misconfiguration: default configs, unnecessary features, error messages revealing info, (6) A06: Vulnerable and Outdated Components: using libraries/frameworks with known vulnerabilities, (7) A07: Identification and Authentication Failures: broken session management, weak passwords, missing MFA, (8) A08: Software and Data Integrity Failures: insecure CI/CD, supply chain attacks, (9) A09: Security Logging and Monitoring Failures: insufficient logging, not detecting breaches, (10) A10: Server-Side Request Forgery (SSRF): forcing server to make unintended requests. Purpose: awareness, prioritization, developer education, security baseline. Updated periodically: 2004, 2007, 2010, 2013, 2017, 2021. Complementary resources: OWASP Testing Guide, OWASP Code Review Guide, OWASP Cheat Sheets. Essential knowledge for all web developers and security professionals."
    }
  ],
  "mode": "elimination"
}