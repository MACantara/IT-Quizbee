{
  "subtopic_id": "inheritance",
  "subtopic_name": "Inheritance",
  "mode": "finals",
  "difficulty": "average",
  "questions": [
    {
      "question": "What is method overriding?",
      "answer": "Child replaces parent method",
      "alternatives": [
        "Method replacement"
      ],
      "explanation": "Override: change implementation. Signature: must match parent. Return type: compatible. Access: cannot be more restrictive. Purpose: customize behavior. Importance: inheritance feature."
    },
    {
      "question": "What is super()?",
      "answer": "Call parent class methods",
      "alternatives": [
        "Parent reference"
      ],
      "explanation": "super(): access parent implementation. Usage: constructors, methods. Benefit: extend parent behavior. Syntax: super.method() or super(). Language: Java, Python, C++. Importance: inheritance technique."
    },
    {
      "question": "What is method resolution order (MRO)?",
      "answer": "Order of method lookup in hierarchy",
      "alternatives": [
        "Method search order"
      ],
      "explanation": "MRO: determines which method called. Multiple inheritance: complex order. Python: uses C3 linearization. Purpose: disambiguate. Example: first found is used. Importance: method lookup."
    },
    {
      "question": "What is polymorphic behavior?",
      "answer": "Objects behave differently based on type",
      "alternatives": [
        "Type-based behavior"
      ],
      "explanation": "Behavior: same method, different results. Based on: object type. Runtime: determined at execution. Benefit: flexibility. Example: Animal.speak() vs Dog.speak(). Importance: polymorphism."
    },
    {
      "question": "What is an abstract method?",
      "answer": "Method without implementation",
      "alternatives": [
        "Unimplemented method"
      ],
      "explanation": "Method: declared but not implemented. Subclasses: must override. Purpose: force implementation. Usage: abstract classes. Benefit: ensure contract. Importance: inheritance pattern."
    },
    {
      "question": "What is an abstract class?",
      "answer": "Cannot be instantiated",
      "alternatives": [
        "Incomplete class"
      ],
      "explanation": "Class: not meant to create objects. Purpose: define interface for subclasses. Methods: can be abstract or concrete. Subclasses: must implement abstract methods. Usage: templates. Importance: inheritance pattern."
    },
    {
      "question": "What is an interface?",
      "answer": "Contract defining methods to implement",
      "alternatives": [
        "Method contract"
      ],
      "explanation": "Interface: pure abstract class. Methods: all abstract (traditionally). No implementation: no state. Multiple: classes can implement. Purpose: define capability. Importance: abstraction mechanism."
    },
    {
      "question": "What is method hiding?",
      "answer": "Static method shadows parent static",
      "alternatives": [
        "Static shadowing"
      ],
      "explanation": "Hiding: static method, not overriding. Difference: overriding for instance, hiding for static. Called: based on reference type. Purpose: class-level method. Importance: static method behavior."
    },
    {
      "question": "What is covariant return type?",
      "answer": "Child returns more specific type",
      "alternatives": [
        "Return type change"
      ],
      "explanation": "Return: child returns subclass of parent return type. Allowed: Java 5+. Benefit: type safety. Example: Parent returns Object, Child returns String. Importance: method override."
    },
    {
      "question": "What is contravariance?",
      "answer": "Parameters accept more general types",
      "alternatives": [
        "Parameter type change"
      ],
      "explanation": "Parameters: child accepts parent type or more general. Rare: most languages don't support. Liskov: can violate principle. Purpose: type flexibility. Importance: type theory."
    }
  ]
}