{
  "subtopic_id": "polymorphism",
  "subtopic_name": "Polymorphism",
  "mode": "finals",
  "difficulty": "average",
  "questions": [
    {
      "question": "What is upcasting?",
      "answer": "Converting child to parent type",
      "alternatives": [
        "Widening cast"
      ],
      "explanation": "Upcasting: child -> parent. Safe: always succeeds. Automatic: implicit casting. Loss: parent methods only. Benefit: polymorphic behavior. Example: Animal animal = new Dog(). Importance: type conversion."
    },
    {
      "question": "What is a generic?",
      "answer": "Type-parameterized class or method",
      "alternatives": [
        "Parameterized type"
      ],
      "explanation": "Generic: placeholder for type. Syntax: <T> angle brackets. Benefit: type safety, reusability. Example: List<String>. Language: Java, C++. Advantage: compile-time type checking. Importance: advanced polymorphism."
    },
    {
      "question": "What is type erasure?",
      "answer": "Generic type info removed at runtime",
      "alternatives": [
        "Type info removal"
      ],
      "explanation": "Erasure: <T> becomes Object at runtime. Reason: backward compatibility. Limitation: cannot check generic type at runtime. Impact: some operations prohibited. Language: Java. Importance: generic implementation."
    },
    {
      "question": "What is PECS?",
      "answer": "Producer extends, Consumer super",
      "alternatives": [
        "Generic rule"
      ],
      "explanation": "PECS: guideline for wildcard generics. Producer: <? extends T> - read-only. Consumer: <? super T> - write-only. Purpose: type safety. Example: List<? extends Number>. Importance: generic best practice."
    },
    {
      "question": "What is a wildcard?",
      "answer": "Unknown type placeholder",
      "alternatives": [
        "Generic unknown"
      ],
      "explanation": "Wildcard: <?> represents any type. Bounded: <? extends Parent>. Upper bound: restricts to Parent. Example: List<?> accepts any list. Purpose: flexibility. Importance: generic syntax."
    },
    {
      "question": "What is contravariance in generics?",
      "answer": "Accepting more general types",
      "alternatives": [
        "Generic contravariance"
      ],
      "explanation": "Contravariance: <? super T>. Parameter: accepts T or superclass. Benefit: flexibility in input. Example: List<? super Integer>. Purpose: consumer pattern. Importance: generic type theory."
    },
    {
      "question": "What is covariance in generics?",
      "answer": "Accepting more specific types",
      "alternatives": [
        "Generic covariance"
      ],
      "explanation": "Covariance: <? extends T>. Return: returns T or subclass. Benefit: flexibility in output. Example: List<? extends Number>. Purpose: producer pattern. Importance: generic type theory."
    },
    {
      "question": "What is invariance in generics?",
      "answer": "Exact type match only",
      "alternatives": [
        "Strict generic typing"
      ],
      "explanation": "Invariance: <T> exact match. List<Integer> not assignable to List<Number>. Reason: type safety. Strictest: most restrictive. Example: generic parameters. Importance: type safety."
    },
    {
      "question": "What is the bridge method?",
      "answer": "Synthetic method for type erasure",
      "alternatives": [
        "Compiler bridge"
      ],
      "explanation": "Bridge: created by compiler. Purpose: maintain polymorphism with type erasure. Hidden: you don't write it. Example: List<String>.add() calls bridge. Importance: generic implementation."
    },
    {
      "question": "What is bounded type parameter?",
      "answer": "Generic type limited to specific types",
      "alternatives": [
        "Type constraint"
      ],
      "explanation": "Bounded: <T extends Number>. Purpose: restrict type parameter. Benefit: use class methods safely. Single: one upper bound. Multiple: multiple interfaces. Importance: generic constraint."
    }
  ]
}