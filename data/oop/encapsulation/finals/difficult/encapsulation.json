{
  "subtopic_id": "encapsulation",
  "subtopic_name": "Encapsulation",
  "mode": "finals",
  "difficulty": "difficult",
  "questions": [
    {
      "question": "What is the principle of least privilege?",
      "answer": "Grant minimum access needed",
      "alternatives": [
        "Least privilege"
      ],
      "explanation": "Privilege: restrict access. Purpose: security. Implementation: make private by default. Benefit: safer. Importance: security principle."
    },
    {
      "question": "What is temporal coupling?",
      "answer": "Methods must be called in specific order",
      "alternatives": [
        "Coupling issue"
      ],
      "explanation": "Temporal: time-dependent ordering. Problem: easy to misuse. Solution: enforce through encapsulation. Example: open() before read(). Importance: design issue."
    },
    {
      "question": "What is the Law of Demeter?",
      "answer": "Talk only to close friends",
      "alternatives": [
        "Demeter principle"
      ],
      "explanation": "Law: avoid a.b.c.d(). Purpose: loose coupling. Implementation: expose only necessary. Benefit: flexibility. Importance: design principle."
    },
    {
      "question": "What is object pooling?",
      "answer": "Reuse expensive objects to reduce allocation",
      "alternatives": [
        "Object reuse"
      ],
      "explanation": "Pooling: maintain pool of ready objects. Purpose: performance. Benefit: reduce GC pressure. Implementation: complex. Importance: optimization."
    },
    {
      "question": "What is the Builder pattern?",
      "answer": "Construct complex objects step by step",
      "alternatives": [
        "Builder"
      ],
      "explanation": "Builder: separate construction. Purpose: readability. Benefit: optional parameters. Example: StringBuilder. Importance: creational pattern."
    },
    {
      "question": "What is a fluent interface?",
      "answer": "Method chaining for readability",
      "alternatives": [
        "Method chaining"
      ],
      "explanation": "Fluent: return this for chaining. Benefit: readable code. Example: obj.set(1).set(2).build(). Importance: API design."
    },
    {
      "question": "What is encapsulation of collection?",
      "answer": "Return unmodifiable collection",
      "alternatives": [
        "Collection safety"
      ],
      "explanation": "Collection: return copy or unmodifiable. Purpose: prevent modification. Benefit: protect internal list. Example: Collections.unmodifiableList(). Importance: data safety."
    },
    {
      "question": "What is the Template Method pattern?",
      "answer": "Define algorithm steps, let subclass override hooks",
      "alternatives": [
        "Template pattern"
      ],
      "explanation": "Template: base structure defined. Hooks: subclass overrides. Purpose: reuse structure. Benefit: consistent. Importance: behavioral pattern."
    },
    {
      "question": "What is a sealed record?",
      "answer": "Immutable sealed data structure",
      "alternatives": [
        "Sealed record"
      ],
      "explanation": "Record: immutable by default. Sealed: restrict implementations. Purpose: data safety. Language: Java 16+. Benefit: safety. Importance: modern feature."
    },
    {
      "question": "What is the proxy pattern?",
      "answer": "Control access via surrogate object",
      "alternatives": [
        "Proxy"
      ],
      "explanation": "Proxy: placeholder for real object. Purpose: lazy loading, logging, access control. Benefit: flexibility. Example: remote proxy. Importance: structural pattern."
    }
  ]
}