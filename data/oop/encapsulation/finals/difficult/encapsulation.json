{
  "subtopic_id": "encapsulation",
  "subtopic_name": "Encapsulation",
  "mode": "finals",
  "difficulty": "difficult",
  "questions": [
    {
      "question": "What Python mechanism performs name mangling for private attributes?",
      "answer": "double underscore prefix",
      "alternatives": [
        "__name",
        "name mangling",
        "dunder prefix"
      ],
      "explanation": "Python mangles names with double underscore to _ClassName__attribute.",
      "id": "enca_enca_d_finals_000"
    },
    {
      "question": "What C++ feature allows granting specific external access to private members?",
      "answer": "friend function",
      "alternatives": [
        "friend class",
        "friend"
      ],
      "explanation": "Friend functions can access private and protected members of a class.",
      "id": "enca_enca_d_finals_001"
    },
    {
      "question": "What design principle suggests using composition over inheritance for encapsulation?",
      "answer": "favor composition",
      "alternatives": [
        "composition over inheritance"
      ],
      "explanation": "Composition provides better encapsulation than inheritance hierarchies.",
      "id": "enca_enca_d_finals_002"
    },
    {
      "question": "What pattern encapsulates object creation logic?",
      "answer": "factory pattern",
      "alternatives": [
        "factory method",
        "abstract factory"
      ],
      "explanation": "Factory pattern hides instantiation details from clients.",
      "id": "enca_enca_d_finals_003"
    },
    {
      "question": "What pattern encapsulates algorithms and makes them interchangeable?",
      "answer": "strategy pattern",
      "alternatives": [
        "strategy"
      ],
      "explanation": "Strategy pattern encapsulates varying behavior in separate classes.",
      "id": "enca_enca_d_finals_004"
    },
    {
      "question": "What mechanism allows controlled access through interfaces only?",
      "answer": "abstraction barrier",
      "alternatives": [
        "interface abstraction"
      ],
      "explanation": "Abstraction barriers separate interface from implementation.",
      "id": "enca_enca_d_finals_005"
    },
    {
      "question": "What Java modifier restricts subclass method overriding?",
      "answer": "final",
      "alternatives": [
        "Final"
      ],
      "explanation": "Final methods cannot be overridden to protect behavior.",
      "id": "enca_enca_d_finals_006"
    },
    {
      "question": "What concept describes exposing only necessary operations?",
      "answer": "interface segregation",
      "alternatives": [
        "minimal interface",
        "lean interface"
      ],
      "explanation": "Interfaces should be specific and not expose unnecessary methods.",
      "id": "enca_enca_d_finals_007"
    },
    {
      "question": "What technique validates state consistency in setters?",
      "answer": "invariant checking",
      "alternatives": [
        "invariants",
        "class invariants"
      ],
      "explanation": "Invariant checking ensures object state remains valid after changes.",
      "id": "enca_enca_d_finals_008"
    },
    {
      "question": "What principle states each module should have limited knowledge of others?",
      "answer": "Law of Demeter",
      "alternatives": [
        "principle of least knowledge",
        "LoD"
      ],
      "explanation": "Law of Demeter promotes loose coupling through minimal interaction.",
      "id": "enca_enca_d_finals_009"
    }
  ]
}