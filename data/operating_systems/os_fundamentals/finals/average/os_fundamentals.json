{
  "subtopic_id": "os_fundamentals",
  "subtopic_name": "OS Fundamentals",
  "mode": "finals",
  "difficulty": "average",
  "questions": [
    {
      "question": "What system call allows a process to create a new process?",
      "answer": "fork",
      "alternatives": [],
      "explanation": "The fork system call creates a child process that is a copy of the parent. It returns different values to parent and child for differentiation."
    },
    {
      "question": "What table maps interrupt numbers to their handler routines?",
      "answer": "Interrupt vector table",
      "alternatives": ["IVT", "Interrupt descriptor table"],
      "explanation": "The interrupt vector table stores addresses of interrupt service routines. When an interrupt occurs, the CPU uses this table to find the handler."
    },
    {
      "question": "What technique allows the OS to execute code with higher privilege?",
      "answer": "System call",
      "alternatives": ["Syscall"],
      "explanation": "System calls provide a controlled interface for user programs to request OS services. They switch from user mode to kernel mode safely."
    },
    {
      "question": "What component translates hardware-specific operations into standard interfaces?",
      "answer": "Device driver",
      "alternatives": ["Driver"],
      "explanation": "Device drivers abstract hardware differences, providing uniform interfaces for OS and applications. Each hardware device needs appropriate drivers."
    },
    {
      "question": "What scheduling approach allows processes to run until they voluntarily yield?",
      "answer": "Cooperative multitasking",
      "alternatives": ["Non-preemptive scheduling"],
      "explanation": "Cooperative multitasking relies on processes yielding control voluntarily. If a process doesn't yield, it can monopolize the CPU."
    },
    {
      "question": "What type of multitasking forces processes to yield periodically?",
      "answer": "Preemptive multitasking",
      "alternatives": ["Preemptive scheduling"],
      "explanation": "Preemptive multitasking uses timer interrupts to force context switches. The OS controls when processes run, preventing CPU monopolization."
    },
    {
      "question": "What boot program loads the operating system into memory?",
      "answer": "Bootloader",
      "alternatives": ["Bootstrap loader"],
      "explanation": "The bootloader is stored in ROM and loads the OS kernel from disk into memory. Examples include GRUB and UEFI bootloaders."
    },
    {
      "question": "What OS layer provides common services to all applications?",
      "answer": "System libraries",
      "alternatives": ["API layer"],
      "explanation": "System libraries provide standard functions for common operations like file I/O and memory allocation. They simplify application development."
    },
    {
      "question": "What mechanism protects memory by preventing unauthorized access?",
      "answer": "Memory protection",
      "alternatives": ["Address space isolation"],
      "explanation": "Memory protection uses hardware support to prevent processes from accessing unauthorized memory. It ensures process isolation and system stability."
    },
    {
      "question": "What allows the CPU to continue execution while waiting for I/O?",
      "answer": "Asynchronous I/O",
      "alternatives": ["Non-blocking I/O"],
      "explanation": "Asynchronous I/O lets processes continue execution while I/O operations complete in the background. Notifications occur via interrupts or callbacks."
    }
  ]
}