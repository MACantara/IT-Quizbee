{
  "subtopic_id": "solid_principles",
  "subtopic_name": "SOLID Principles",
  "mode": "elimination",
  "questions": [
    {
      "question": "What does the S in SOLID stand for?",
      "options": [
        "Separate Responsibility",
        "Single Responsibility",
        "Simple Responsibility",
        "Specific Responsibility"
      ],
      "correct": 1,
      "explanation": "Single Responsibility Principle states classes should have one reason to change.",
      "id": "oop_sol_pri_elim_000"
    },
    {
      "question": "What does the O in SOLID stand for?",
      "options": [
        "Open/Closed",
        "Object-Oriented",
        "Optional",
        "Operational"
      ],
      "correct": 0,
      "explanation": "Open/Closed Principle states classes should be open for extension but closed for modification.",
      "id": "oop_sol_pri_elim_001"
    },
    {
      "question": "What does the L in SOLID stand for?",
      "options": [
        "Layered Substitution",
        "Linked Substitution",
        "Liskov Substitution",
        "Logical Substitution"
      ],
      "correct": 2,
      "explanation": "Liskov Substitution Principle ensures subtypes can replace base types.",
      "id": "oop_sol_pri_elim_002"
    },
    {
      "question": "What does the I in SOLID stand for?",
      "options": [
        "Interface Segregation",
        "Implementation Segregation",
        "Inheritance Segregation",
        "Integration Segregation"
      ],
      "correct": 0,
      "explanation": "Interface Segregation Principle states clients should not depend on unused interfaces.",
      "id": "oop_sol_pri_elim_003"
    },
    {
      "question": "What does the D in SOLID stand for?",
      "options": [
        "Data Inversion",
        "Design Inversion",
        "Dependency Inversion",
        "Development Inversion"
      ],
      "correct": 2,
      "explanation": "Dependency Inversion Principle promotes abstraction over concretion.",
      "id": "oop_sol_pri_elim_004"
    },
    {
      "question": "What principle prevents classes from having multiple reasons to change?",
      "options": [
        "Open/Closed",
        "Single Responsibility",
        "Liskov Substitution",
        "Interface Segregation"
      ],
      "correct": 1,
      "explanation": "Single Responsibility limits class responsibilities.",
      "id": "oop_sol_pri_elim_005"
    },
    {
      "question": "What principle allows extending behavior without modification?",
      "options": [
        "Single Responsibility",
        "Open/Closed",
        "Liskov Substitution",
        "Dependency Inversion"
      ],
      "correct": 1,
      "explanation": "Open/Closed Principle enables extension through inheritance and composition.",
      "id": "oop_sol_pri_elim_006"
    },
    {
      "question": "What principle ensures subclasses maintain parent contracts?",
      "options": [
        "Single Responsibility",
        "Open/Closed",
        "Liskov Substitution",
        "Interface Segregation"
      ],
      "correct": 2,
      "explanation": "Liskov Substitution ensures behavioral compatibility.",
      "id": "oop_sol_pri_elim_007"
    },
    {
      "question": "What principle prevents large interfaces?",
      "options": [
        "Single Responsibility",
        "Open/Closed",
        "Interface Segregation",
        "Dependency Inversion"
      ],
      "correct": 2,
      "explanation": "Interface Segregation favors specific interfaces over general ones.",
      "id": "oop_sol_pri_elim_008"
    },
    {
      "question": "What principle encourages depending on abstractions?",
      "options": [
        "Single Responsibility",
        "Liskov Substitution",
        "Interface Segregation",
        "Dependency Inversion"
      ],
      "correct": 3,
      "explanation": "Dependency Inversion depends on abstractions not concretions.",
      "id": "oop_sol_pri_elim_009"
    }
  ]
}