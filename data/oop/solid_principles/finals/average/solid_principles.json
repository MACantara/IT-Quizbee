{
  "subtopic_id": "solid_principles",
  "subtopic_name": "SOLID Principles",
  "mode": "finals",
  "difficulty": "average",
  "questions": [
    {
      "question": "What is violation of ISP?",
      "answer": "Interface with unnecessary methods",
      "alternatives": [
        "ISP violation"
      ],
      "explanation": "Violation: fat interface. Problem: forced implementation. Solution: split. Example: Mouse, Keyboard, TouchScreen. Importance: understanding."
    },
    {
      "question": "What is violation of DIP?",
      "answer": "Depend directly on concrete classes",
      "alternatives": [
        "DIP violation"
      ],
      "explanation": "Violation: tight coupling. Problem: hard to swap. Solution: abstraction. Example: new DataBase() vs inject. Importance: understanding."
    },
    {
      "question": "How does SRP relate to cohesion?",
      "answer": "Both aim for related functionality together",
      "alternatives": [
        "SRP and cohesion"
      ],
      "explanation": "Relation: both improve code. SRP: enforce single purpose. Cohesion: high relatedness. Goal: well-organized. Importance: design metric."
    },
    {
      "question": "How does OCP relate to abstraction?",
      "answer": "Abstraction enables extension without modification",
      "alternatives": [
        "OCP and abstraction"
      ],
      "explanation": "Relation: abstraction allows OCP. Method: interfaces, inheritance. Benefit: flexibility. Example: strategy pattern. Importance: design technique."
    },
    {
      "question": "How does ISP relate to cohesion?",
      "answer": "Specific interfaces have high cohesion",
      "alternatives": [
        "ISP and cohesion"
      ],
      "explanation": "Relation: specific interfaces cohesive. ISP: focused contracts. Cohesion: related operations. Benefit: understanding. Importance: design metric."
    },
    {
      "question": "What is interface pollution?",
      "answer": "Interface with too many unrelated methods",
      "alternatives": [
        "Fat interface"
      ],
      "explanation": "Pollution: bloated interface. Problem: forced implementation. Solution: ISP segregation. Example: large utility interface. Importance: design issue."
    },
    {
      "question": "What is the difference between refactoring and redesign?",
      "answer": "Refactoring maintains behavior, redesign changes",
      "alternatives": [
        "Change types"
      ],
      "explanation": "Refactoring: improve, same behavior. Redesign: new structure. SOLID: enables refactoring. Purpose: gradual improvement. Importance: development practice."
    },
    {
      "question": "What is the Dependency Injection Container?",
      "answer": "Framework managing dependencies",
      "alternatives": [
        "DI Container"
      ],
      "explanation": "Container: manages creation and wiring. Purpose: automatic injection. Benefit: centralized control. Example: Spring, Guice. Importance: DIP implementation."
    },
    {
      "question": "What is Constructor Injection?",
      "answer": "Dependencies passed via constructor",
      "alternatives": [
        "Constructor DI"
      ],
      "explanation": "Constructor: declare dependencies. Benefit: required dependencies visible. Immutable: good for final. Example: new Service(dependency). Importance: DIP pattern."
    },
    {
      "question": "What is Setter Injection?",
      "answer": "Dependencies set via setter methods",
      "alternatives": [
        "Setter DI"
      ],
      "explanation": "Setter: optional dependencies. Benefit: flexible configuration. Drawback: optional not obvious. Example: setLogger(). Importance: DIP pattern."
    }
  ]
}