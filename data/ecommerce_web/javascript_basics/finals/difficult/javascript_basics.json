{
  "subtopic_id": "javascript_basics",
  "subtopic_name": "JavaScript Basics",
  "mode": "finals",
  "difficulty": "difficult",
  "questions": [
    {
      "question": "What manages asynchronous operations?",
      "answer": "Promise",
      "alternatives": [
        "JavaScript Promise"
      ],
      "explanation": "Promise represents eventual completion of async operation. States: pending, fulfilled, rejected. Then/catch: handle results. Syntax: new Promise((resolve, reject) => {...}). Chaining: multiple operations in sequence. Modern: fetch() returns Promise. Foundation of async JavaScript."
    },
    {
      "question": "What simplifies async code?",
      "answer": "Async/await",
      "alternatives": [
        "Async function"
      ],
      "explanation": "Async/await simplifies Promise handling. async: function returns Promise. await: pause until Promise resolves. Syntax: async function() { const result = await promise; }. Cleaner than .then(). Error handling: try/catch. Modern approach: preferred over callbacks."
    },
    {
      "question": "What prevents variable mutation?",
      "answer": "Immutability",
      "alternatives": [
        "Const, object freeze"
      ],
      "explanation": "Immutability prevents unintended data changes. const: prevent reassignment. Object.freeze(): prevent modification. Benefits: predictability, debugging. Functional programming: compose functions without side effects. Libraries: Immer.js, Immutable.js. Important for large applications."
    },
    {
      "question": "What shares code between objects?",
      "answer": "Prototype",
      "alternatives": [
        "Inheritance"
      ],
      "explanation": "Prototype enables code sharing between objects. Object inherits properties from prototype. Chain: prototype of prototype. Constructor: uses prototype. Modern: classes (syntactic sugar for prototypes). Understanding: essential for JavaScript mastery."
    },
    {
      "question": "What encapsulates related data?",
      "answer": "Class",
      "alternatives": [
        "ES6 class"
      ],
      "explanation": "Class organizes data and methods. Syntax: class Name { constructor() {...} method() {...} }. Constructor: initialization. Inheritance: extends. Modern: replaces function constructors. Object-oriented: model real-world entities. Methods: behaviors."
    },
    {
      "question": "What fetches remote data?",
      "answer": "fetch()",
      "alternatives": [
        "Fetch API"
      ],
      "explanation": "fetch() retrieves data from URLs. Returns: Promise resolving to Response. JSON: response.json(). Syntax: fetch(url).then(r => r.json()).then(data => {...}). Async/await: cleaner. Error handling: try/catch. Modern: replaces XMLHttpRequest."
    },
    {
      "question": "What parses JSON text?",
      "answer": "JSON.parse()",
      "alternatives": [
        "JSON parsing"
      ],
      "explanation": "JSON.parse() converts JSON string to object. Opposite: JSON.stringify(). Text from server: parsed to use. Syntax: const obj = JSON.parse(jsonString). Error: invalid JSON throws. Common: API responses. Format: human-readable data exchange."
    },
    {
      "question": "What isolates variable scope?",
      "answer": "Closure",
      "alternatives": [
        "Function closure"
      ],
      "explanation": "Closure accesses outer function variables. Inner function: remembers outer scope. Syntax: function outer() { let x; function inner() { use x; } }. Data privacy: encapsulation. Callbacks: closures capture context. Advanced: powerful for complex patterns."
    },
    {
      "question": "What combines multiple functions?",
      "answer": "Higher-order function",
      "alternatives": [
        "Function composition"
      ],
      "explanation": "Higher-order function takes or returns function. Examples: map(), filter(), setTimeout(). Functional programming: building blocks. Composition: combine simpler functions. Abstraction: complex logic from simple parts. Powers modern libraries."
    },
    {
      "question": "What manages application state?",
      "answer": "State management",
      "alternatives": [
        "Redux",
        "Vuex"
      ],
      "explanation": "State management centralizes application data. Libraries: Redux, Vuex, Context API. Single source of truth: prevent inconsistency. Actions: describe changes. Reducers: apply changes. Debugging: track state changes. Scalability: complex applications."
    }
  ]
}