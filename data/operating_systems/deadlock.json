{
  "subtopic_id": "deadlock",
  "subtopic_name": "Deadlock",
  "questions": [
    {
      "question": "What is a deadlock?",
      "options": [
        "A situation where processes are permanently blocked waiting for resources held by each other",
        "When a process crashes",
        "When memory is full",
        "When the CPU is idle"
      ],
      "correct": 0,
      "explanation": "A deadlock is a situation where a set of processes are permanently blocked because each process is holding a resource and waiting for another resource held by another process in the set. No process can proceed."
    },
    {
      "question": "What are the four necessary conditions for deadlock (Coffman conditions)?",
      "options": [
        "Mutual Exclusion, Hold and Wait, No Preemption, Circular Wait",
        "Fast CPU, Large Memory, Good Network, Fast Disk",
        "Single User, Multiple Processes, High Priority, Low Memory",
        "Sequential Access, Random Access, Direct Access, Indexed Access"
      ],
      "correct": 0,
      "explanation": "The four necessary conditions for deadlock are: 1) Mutual Exclusion (resources can't be shared), 2) Hold and Wait (processes hold resources while waiting for more), 3) No Preemption (resources can't be forcibly taken), 4) Circular Wait (circular chain of processes waiting for resources)."
    },
    {
      "question": "What is Mutual Exclusion in deadlock?",
      "options": [
        "At least one resource must be non-shareable; only one process can use it at a time",
        "Multiple processes can use the same resource",
        "All resources are shareable",
        "Resources can be duplicated"
      ],
      "correct": 0,
      "explanation": "Mutual Exclusion means that at least one resource must be held in a non-shareable mode. Only one process can use the resource at a time. If another process requests it, that process must wait."
    },
    {
      "question": "What is the 'Hold and Wait' condition?",
      "options": [
        "A process holds at least one resource while waiting for additional resources",
        "Processes don't hold any resources",
        "Processes wait without holding resources",
        "Resources are released immediately"
      ],
      "correct": 0,
      "explanation": "Hold and Wait means a process is holding at least one resource and is waiting to acquire additional resources that are currently being held by other processes."
    },
    {
      "question": "What is 'No Preemption' in the context of deadlock?",
      "options": [
        "Resources cannot be forcibly taken from a process; they must be voluntarily released",
        "Resources can be taken anytime",
        "The OS can always take resources",
        "Processes can steal resources"
      ],
      "correct": 0,
      "explanation": "No Preemption means resources cannot be forcibly removed from a process. A resource can only be released voluntarily by the process holding it after completing its task."
    },
    {
      "question": "What is 'Circular Wait'?",
      "options": [
        "A circular chain of processes where each waits for a resource held by the next process",
        "Processes wait in a line",
        "Random waiting pattern",
        "Processes don't wait"
      ],
      "correct": 0,
      "explanation": "Circular Wait exists when there is a circular chain of two or more processes, where each process is waiting for a resource held by the next process in the chain, forming a cycle."
    },
    {
      "question": "What is deadlock prevention?",
      "options": [
        "Ensuring that at least one of the four deadlock conditions cannot hold",
        "Detecting deadlocks after they occur",
        "Ignoring deadlocks",
        "Allowing deadlocks to happen"
      ],
      "correct": 0,
      "explanation": "Deadlock prevention involves designing a system such that at least one of the four necessary conditions (Mutual Exclusion, Hold and Wait, No Preemption, Circular Wait) cannot occur, making deadlock impossible."
    },
    {
      "question": "What is deadlock avoidance?",
      "options": [
        "Using algorithms to ensure the system never enters an unsafe state",
        "Detecting and recovering from deadlocks",
        "Ignoring deadlocks completely",
        "Restarting the system"
      ],
      "correct": 0,
      "explanation": "Deadlock avoidance uses algorithms (like Banker's Algorithm) to dynamically examine the resource-allocation state to ensure the system never enters an unsafe state where deadlock could occur."
    },
    {
      "question": "What is the Banker's Algorithm?",
      "options": [
        "A deadlock avoidance algorithm that checks if granting a resource request keeps the system in a safe state",
        "An algorithm for banking software",
        "A scheduling algorithm",
        "A memory management algorithm"
      ],
      "correct": 0,
      "explanation": "The Banker's Algorithm is a deadlock avoidance algorithm that simulates resource allocation to determine if granting a resource request will leave the system in a safe state (where all processes can complete). It only grants requests that keep the system safe."
    },
    {
      "question": "What is deadlock detection and recovery?",
      "options": [
        "Allowing deadlocks to occur, then detecting and resolving them",
        "Preventing all deadlocks",
        "Avoiding unsafe states",
        "Ignoring deadlocks"
      ],
      "correct": 0,
      "explanation": "Deadlock detection and recovery allows deadlocks to occur, then uses algorithms to detect them (often using resource allocation graphs) and recovery mechanisms like process termination or resource preemption to break the deadlock."
    }
  ]
}