{
  "subtopic_id": "advanced_oop",
  "subtopic_name": "Advanced OOP",
  "mode": "finals",
  "difficulty": "average",
  "questions": [
    {
      "question": "What is type erasure?",
      "answer": "Generic type information removed at runtime",
      "alternatives": [
        "Type removal"
      ],
      "explanation": "Erasure: <T> becomes Object. Reason: compatibility. Limitation: no runtime type checking. Language: Java. Importance: implementation."
    },
    {
      "question": "What is covariance?",
      "answer": "Accept more specific types",
      "alternatives": [
        "Variance type"
      ],
      "explanation": "Covariance: <? extends T>. Return: subtype. Purpose: flexibility. Example: List<? extends Number>. Importance: generic theory."
    },
    {
      "question": "What is contravariance?",
      "answer": "Accept more general types",
      "alternatives": [
        "Variance type"
      ],
      "explanation": "Contravariance: <? super T>. Parameter: supertype. Purpose: flexibility. Example: List<? super Integer>. Importance: generic theory."
    },
    {
      "question": "What is the PECS principle?",
      "answer": "Producer extends, Consumer super",
      "alternatives": [
        "Wildcard rule"
      ],
      "explanation": "PECS: guideline. Producer: <? extends>. Consumer: <? super>. Purpose: type safety. Importance: generic best practice."
    },
    {
      "question": "What is a sealed class?",
      "answer": "Restrict which classes can extend",
      "alternatives": [
        "Sealed inheritance"
      ],
      "explanation": "Sealed: limit. Purpose: control hierarchy. Language: Java 17+. Benefit: predictable. Importance: modern feature."
    },
    {
      "question": "What is a record?",
      "answer": "Immutable data class",
      "alternatives": [
        "Data class"
      ],
      "explanation": "Record: auto constructor, equals, toString. Purpose: data. Language: Java 14+. Benefit: less boilerplate. Importance: modern feature."
    },
    {
      "question": "What is the visitor pattern?",
      "answer": "Separate operations from structure",
      "alternatives": [
        "Double dispatch"
      ],
      "explanation": "Visitor: operation objects. Purpose: add operations without modification. Pattern: double dispatch. Importance: behavioral."
    },
    {
      "question": "What is the strategy pattern?",
      "answer": "Encapsulate interchangeable algorithms",
      "alternatives": [
        "Algorithm choice"
      ],
      "explanation": "Strategy: swappable. Purpose: runtime selection. Benefit: extensible. Example: payment methods. Importance: behavioral."
    },
    {
      "question": "What is lazy evaluation?",
      "answer": "Defer computation until needed",
      "alternatives": [
        "Deferred computation"
      ],
      "explanation": "Lazy: on-demand. Purpose: performance. Benefit: save work. Language: Haskell default. Importance: evaluation strategy."
    },
    {
      "question": "What is currying?",
      "answer": "Transform function with multiple args to single-arg functions",
      "alternatives": [
        "Partial application"
      ],
      "explanation": "Currying: chain functions. Purpose: partial application. Language: functional. Benefit: composable. Importance: FP technique."
    }
  ]
}